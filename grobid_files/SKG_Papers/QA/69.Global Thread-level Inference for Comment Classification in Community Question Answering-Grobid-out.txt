title
Global Thread-Level Inference for Comment Classification in Community Question Answering

abstract
Community question answering, a recent evolution of question answering in the Web context, allows a user to quickly consult the opinion of a number of people on a particular topic, thus taking advantage of the wisdom of the crowd. Here we try to help the user by deciding automatically which answers are good and which are bad for a given question. In particular, we focus on exploiting the output structure at the thread level in order to make more consistent global decisions. More specifically, we exploit the relations between pairs of comments at any distance in the thread, which we incorporate in a graph-cut and in an ILP frameworks. We evaluated our approach on the benchmark dataset of SemEval-2015 Task 3. Results improved over the state of the art, confirming the importance of using thread level information.

Introduction Community question answering (CQA) is a recent evolution of question answering, in the Web context, where users pose questions and then receive answers from other users. This setup is very attractive, as the anonymity on the Web allows users to ask just about anything and then hope to get some honest answers from a number of people. On the negative side, there is no guarantee about the quality of the answers as people of very different background, knowledge, and with different motivation contribute answers to a given question. Unlike traditional question answering (QA), in CQA answering takes the form of commenting in a forum. Thus, many comments are only loosely connected to the original question, and some are not answers at all, but are rather interactions between users. As question-comment threads can get quite long, finding good answers in a thread can be timeconsuming. This has triggered research in trying to automatically determine which answers might be good and which ones are likely to be bad or irrelevant. One early work going in this direction is that of  Qu and Liu (2011) , who tried to determine whether a question is "solved" or not, given its associated thread of comments. As a first step in the process, they performed a comment-level classification, considering four classes: problem, solution, good feedback, and bad feedback. More recently, the shared task at SemEval 2015 on Answer Selection in CQA , whose benchmark datasets we will use below, tackled the task of identifying good, potentially useful, and bad comments within a thread. In that task, the top participating systems used threadlevel features, in addition to the usual local features that only look at the question-answer pair. For example, the second-best team, HITSZ-ICRC, used as a feature the position of the comment in the thread  (Hou et al., 2015) . Similarly, our participation, which achieved the third-best postition, used features that try to describe a comment in the context of the entire comment thread, focusing on user interaction  (Nicosia et al., 2015) . Finally, the fifth-best team, ICRC-HIT, treated the answer selection task as a sequence labeling problem and proposed recurrent convolution neural networks to recognize good comments  (Zhou et al., 2015b) . In a follow-up work,  Zhou et al. (2015a)  included a long-short term memory in their convolution neural network to learn the classification sequence for the thread. In parallel, in our recent work , we tried to exploit the dependencies between the thread comments to tackle the same task. We did it by designing features that look globally at the thread and by applying structured prediction models, such as Conditional Random Fields  (Lafferty et al., 2001) . Our goal in this paper goes in the same direction: we are interested in exploiting the output structure at the thread level to make more consistent global assignments. To the best of our knowledge, there is no work in QA that identifies good answers based on the selection of the other answers retrieved for a question. This is mainly due to the loose dependencies between the different answer passages in standard QA. In contrast, we postulate that in a CQA setting, the answers from different users in a common thread are strongly interconnected and, thus, a joint answer selection model should be adopted to achieve higher accuracy. In particular, we focus on the relations between two comments at any distance in the thread. This is more general than previous approaches, which were either limited to sequential interactions or considered conversational interactions only at the level of features. We propose a model based on the idea that similar comments should have similar labels. Below, we apply graph-cut and we compare it to an integer linear programming (ILP) formulation for decoding under global constraints; we also provide results with a linear-chain CRF. We show that the CRF is ineffective due to long-distance relations, e.g., a conversation in a thread can branch and then come back later. On the contrary, the global inference models (either graph-cut or ILP) using the similarity between pairs of comments manage to significantly improve a strong baseline performing local comment-based classifications. 

 The Task We use the CQA-QL corpus from Subtask A of SemEval-2015 Task 3 on Answer Selection in CQA. The corpus contains data from the Qatar Living forum, 1 and is publicly available on the task's website.  2  The dataset consists of questions and a list of answers for each question, i.e., question-answer threads. Each question, and each answer, consist of a short title and a more detailed description. There is also meta information associated with both, e.g., ID of the user asking/answering the question, timestamp, category. The task asks participants to determine for each answer in the thread whether it is Good, Bad, or Potentially useful for the given question.  A simplified example is shown in Figure  1 , 3 where answers 2 and 4 are good, answer 1 is potentially useful, and answer 3 is bad. In this paper, we focus on a 2-class variant of the above Subtask A, which is closer to a real CQA application. We merge Potential and Bad labels into Bad and we focus on the 2-class problem: Good-vs-Bad. Table  1  shows some statistics about the resulting dataset used for development, training and testing.  

 Category 

 Our Proposed Solution We model the pairwise relations between the comments in the answer thread ({c i } n i=1 ) to produce a better global assignment: we combine the predictions of a Good-vs-Bad classifier at the comment level with the output of a pairwise classifier, Samevs-Different, which takes two comments and predicts whether they should have the same label. Each comment c i has an individual score s iK , provided by the Good-vs-Bad classifier, for being in class K ? {G, B} (i.e., G for Good and B for Bad). Moreover, for each pair of comments (c i , c j ), we have an association score s ij , an estimate by the pairwise classifier about how likely it is that the comments c i and c j will have the same label. Next, we define two ways of doing global inference using these two sources of information. 

 Graph Partition Approach Here our goal is to find a partition P = (G, B) that minimizes the following cost: C(P ) = ? c i ?G s iB + c i ?B s iG + (1 ? ?) c i ?G,c j ?B s ij The first part of the cost function discourages misclassification of individual comments, while the second part encourages similar comments to be in the same class. The mixing parameter ? ? [0, 1] determines the relative strength of the two components. Our approach is inspired by  Pang and Lee (2004) , where they model the proximity relation between sentences for finding subjective sentences in product reviews, whereas we are interested in global inference based on local classifiers. The optimization problem can be efficiently solved by finding a minimum cut of a weighted undirected graph G = (V, E). The set of nodes V = {v 1 , v 2 , ? ? ? , v n , s, t} represent the n comments in a thread, the source and the sink. We connect each comment node v i to the source node s by adding an edge w(v i , s) with capacity s iG , and to the sink node t by adding an edge w(v i , t) with capacity s iB . Finally, we add edges w(v i , v j ) with capacity s ij to connect all pairs of comments. Minimizing C(P ) amounts to finding a partition (S, T ), where S = {s} ? S and T = {t} ? T for s / ? S , t / ? T , that minimizes the cut capacity, i.e., the net flow crossing from S to T . One crucial advantage of this approach is that we can use max-flow algorithms to find the exact solution in polynomial time -near-linear in practice  (Cormen et al., 2001; Boykov and Kolmogorov, 2004) . 

 Integer Linear Programming Approach Here we follow the inference with classifiers approach by  Roth and Yih (2004) , solved with Integer Linear Programming (ILP). We have one ILP problem per question-answer thread. We define a set of binary variables, whose assignment will univocally define the classification of all comments in the thread. In particular, we define a pair of variables for each answer: x iG and x iB , 1 ? i ? n. Assigning 1 to x iG means that comment c i in the thread is classified as Good; assigning it 0 means that c i is not classified as Good. The same applies to the other classes (here, only Bad). Also, we have a pair of variables for each pair of comments (to capture the pairwise relations): x ijS and x ijD , 1 ? i < j ? n. Assigning 1 to x ijS means that c i and c j have the same label; assigning 0 to x ijS means that c i and c j do not have the same label. The same interpretation holds for the other possible classes (in this case only Different).  4  Let c iG be the cost of classifying c i as Good, c ijS be the cost of assigning the same labels to c i and c j , etc. Following  (Roth and Yih, 2004) , these costs are obtained from local classifiers by taking log probabilities, i.e., c iG = ? log s iG , c ijS = ? log s ij , etc. The goal of the ILP problem is to find an assignment A to all variables x iG , x iB , x ijS , x ijD that minimizes the cost function: C(A) = ? ? N i=1 (c iG ? x iG + c iB ? x iB ) + (1 ? ?) ? N ?1 i=1 N j=i+1 (c ijS ? x ijS + c ijD ? x ijD ) subject to the following constraints: (i) All variables are binary; (ii) One and only one label is assigned to each comment or pair of comments; (iii) The assignments to the comment variables and to the comment-pair variables are consistent: x ijD = x iG ? x jG , ?i, j 1 ? i < j ? n. ? ? [0, 1] is a parameter used to balance the contribution of the two sources of information. 

 Local Classifiers For classification, we use Maximum Entropy, or MaxEnt,  (Murphy, 2012) , as it yields a probability distribution over the class labels, which we then use directly for the graph arcs and the ILP costs. 

 Good-vs-Bad Classifier Our most important features measure the similarity between the question (q) and the comment (c). We compare lemmata and POS [1-4]-grams using  Jaccard (1901) , containment  (Lyon et al., 2001) , and cosine, as well as using some similarities from DKPro  (B?r et al., 2012)  such as longest common substring  (Allison and Dix, 1986 ) and greedy string tiling  (Wise, 1996) . We also compute similarity using partial tree kernels  (Moschitti, 2006)  on shallow syntactic trees. Forty-three Boolean features express whether (i) c includes URLs or emails, the words "yes", "sure", "no", "neither", "okay", etc., as well as '?' and '@' or starts with "yes" (12 features); (ii) c includes a word longer than fifteen characters (1); (iii) q belongs to each of the forum categories (26); and (iv) c and q were posted by the same user (  4 ). An extra feature captures the length of c. Four features explore whether c is close to a comment by the user who asked the question, u q : (i-ii) there is a comment by u q following c and (not) containing an acknowledgment or (iii) containing a question, or (iv) among the comments preceding c there is one by u q asking a question. We model dialogues by identifying conversation chains between two users with three features: whether c is at the beginning/middle/end of a chain. There are copies of these features for chains in which u q participates. Another feature for c u i checks whether the user u i wrote more than one comment in the current thread. Three more features fire for the first/middle/last comment by u i . One extra feature counts the total number of comments written by u i . Finally, there is a feature modeling the position of c in the thread. 

 Same-vs-Different Classifier We use the following types of features for a pair of comments (c i , c j ): (i) all the features from the Good-vs-Bad classifier (i.e., we subtracted the feature vectors representing the two comments, |v i ? v j |) 5 ; (ii) the similarity features between the two comments, sim(c i , c j ); and (iii) the prediction from the Good-vs-Bad classifiers on c i and c j (i.e., the scores for c i and c j , the product of the two scores, and five boolean features specifying whether any of c i and c j are predicted as Good, Bad, and whether their predictions are identical). 

 Experiments and Evaluation We performed standard pre-processing, and we further filtered user's signatures. All parameters (e.g., Gaussian prior for MaxEnt and the mixing ? for the graph-cut and ILP) were tuned on the development set. We also trained a second-order linear-chain CRF to check the contribution of the sequential relations between comments. We report results on the official SemEval test set for all methods. For the Same-vs-Different problem, we explored a variant of training with three classes, by splitting the Same class into Same-Good and Same-Bad. At test time, the probabilities of these two subclasses are added to get the probability of Same and all the algorithms are run unchanged.  5  Subtracting vectors is standard in preference learning  (Shen and Joshi, 2003) . The absolute value is necessary to emphasize comment differences instead of preferences. Table  2  shows the results for the Same-vs-Different classification. We can see that the twoclass MaxEnt-2C classifier works better than the three-class MaxEnt-3C. MaxEnt-3C has more balanced P and R, but loses in both F 1 and accuracy. MaxEnt-2C is very skewed towards the majority class, but performs better due to the class imbalance. Overall, it seems very difficult to learn with the current features, and both methods only outperform the majority-class baseline by a small margin. Yet, while the overall accuracy is low, note that the graph-cut/ILP inference allows us to recover from some errors, because if nearby utterances are clustered correctly, the wrong decisions should be outvoted by correct ones. The results for Good-vs-Bad are shown in Table 3. On the top are the best systems at SemEval-2015 Task 3. We can see that our MaxEnt classifier is competitive: it shows higher accuracy than two of them, and the highest F 1 overall.   3 : Good-vs-Bad classification. ? and ? mark statistically significant differences in accuracy compared to the baseline MaxEnt classifier with confidence levels of 99% and 95%, respectively (randomized test). The CRF model is worse than MaxEnt on all measures, which suggests that the sequential information does not help. This can be because many interactions between comments are long-distance and there are gaps in the threads due to the annotation procedure at SemEval . However, global inference with graph-cut and ILP improves both F 1 and accuracy, mostly due to better recall. Graph-cut works better than ILP as it has higher precision, which helps F 1 and accuracy. Both yield statistically significant improvements over the MaxEnt classifier; they also improve over the state-of-the-art JAIST system. Note that the devtest-tuned values of ? for graph-cut and ILP put much lower weight to the Same-vs-Different component (values are 0.95 and 0.91, respectively). Finally, as expected, using the predictions of MaxEnt-2C in the global classifiers is better than using those from MaxEnt-3C.   

 Discussion We manually examined a number of examples where our global classfier could successfully recover from the errors made by the local classifier, and where it failed to do so. In Figure  2 , we show the classification decisions of our local and global (graph-cut) classifiers along with the human annotations for an excerpt of a thread. For example, consider answers A 6 , A 9 , and A 12 , which were initially misclassified as Bad by the local classifier, but later recovered by the global classifier exploiting the pairwise information. In this case, the votes received by these answers from other Good answers in the thread for being in the same class won against the votes received from other Bad answers. Now consider A 11 , which our method failed to classify correctly as Good. Our investigation revealed that in this case the votes from the Bad answers won against the votes from the Good ones. The accuracy of the pairwise classifier has proven to be crucial for the performance of our overall framework. We probably need more informative features (e.g., textual entailment and semantic similarity to capture the relation between books and novels, movies and DVDs, etc.) in order to improve the pairwise classification performance. 

 Conclusion and Future Work We have investigated the use of thread-level information for answer selection in CQA. We have shown that using a pairwise classifier that predicts whether two comments should get the same label, followed by a graph-cut (or ILP) global inference improves significantly over a very strong baseline as well as over the state of the art. We have further shown that using a linear-chain CRF model does not help, probably because many interactions between comments are long distance. In future work, we would like to improve the pairwise classifiers with richer features, as this is currently the bottleneck for improving the performance in the global model. We further plan to test our framework on other CQA datasets, including on other languages.  7  Last but not least, we are interested in extending this research with even more global information, e.g., by modeling global decision consistency across multiple threads. Figure 1 : 1 Figure 1: Example from SemEval-2015 Task 3. 
