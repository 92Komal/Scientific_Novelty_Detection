title
Learning When Not to Answer: A Ternary Reward Structure for Reinforcement Learning based Question Answering

abstract
In this paper, we investigate the challenges of using reinforcement learning agents for question-answering over knowledge graphs for real-world applications. We examine the performance metrics used by state-of-the-art systems and determine that they are inadequate for such settings. More specifically, they do not evaluate the systems correctly for situations when there is no answer available and thus agents optimized for these metrics are poor at modeling confidence. We introduce a simple new performance metric for evaluating question-answering agents that is more representative of practical usage conditions, and optimize for this metric by extending the binary reward structure used in prior work to a ternary reward structure which also rewards an agent for not answering a question rather than giving an incorrect answer. We show that this can drastically improve the precision of answered questions while only not answering a limited number of previously correctly answered questions. Employing a supervised learning strategy using depth-first-search paths to bootstrap the reinforcement learning algorithm further improves performance.

Introduction A number of approaches for question answering have been proposed recently that use reinforcement learning to reason over a knowledge graph  (Das et al., 2018; Lin et al., 2018; Chen et al., 2018; Zhang et al., 2018) . In these methods the input question is first parsed into a constituent question entity and relation. The answer entity is then identified by sequentially taking a number of steps (or 'hops') over the knowledge graph (KG) starting from the question entity. The agent receives a positive reward if it arrives at the correct answer entity and a negative reward for an incorrect answer entity. For example, for the question Lives in Figure  1 : Fictional graph for the the question "What's the capital of France?". The relation (Capital of ) does not exist in the graph and thus an alternative path needs to be used that leads to the correct answer. "What is the capital of France?", the question entity is (F rance) and the goal is to find a path in the KG which connects it to (P aris). The relation between the answer entity and question entity in this example is (Capital of ) which is missing from the KG and has to be inferred via alternative paths. This is illustrated in Figure  1 . A possible two-hop path to find the answer is to use the fact that (M acron) is the president of (F rance) and that he lives in (P aris). However, there are many paths that lead to the entity (P aris) but also to other entities which makes finding the correct answer a non-trivial task. The standard evaluation metrics used for these systems are metrics developed for web search such as Mean Reciprocal Rank (MRR) and hits@k, where k ranges from 1 to 20. We argue that this is not a correct evaluation mechanism for a practical question-answering system (such as Alexa,  Cortana, Siri, etc.)  where the goal is to return a single answer for each question. Moreover it is assumed that there is always an answer entity that could be reached from the question entity in limited number of steps. However this cannot be guaranteed in a large-scale commercial setting and for all KGs. For example, in our proprietary dataset used for the experimentation, for 15.60% of questions the answer entity cannot be reached within the limit of number of steps used by the agent. Hence, we propose a new evaluation criterion, allowing systems to return 'no answer' as a response when no answer is available. We demonstrate that existing state-of-the-art methods are not suited for a practical questionanswering setting and perform poorly in our evaluation setup. The root-cause of poor performance is the reward structure which does not provide any incentive to learn not to answer. The modified reward structure we present allows agents to learn not to answer in a principled way. Rather than having only two rewards, a positive and a negative reward, we introduce a ternary reward structure that also rewards agents for not answering a question. A higher reward is given to the agent for correctly answering a question compared to not answering a question. In this setup the agent learns to make a trade-off between these three possibilities to obtain the highest total reward over all questions. Additionally, because the search space of possible paths exponentially grows with the number of hops, we also investigate using Depth-First-Search (DFS) algorithm to collect paths that lead to the correct answer. We use these paths as a supervised signal for training the neural network before the reinforcement learning algorithm is applied. We show that this improves overall performance. 

 Related work The closest works to ours are the works by Lin et al. (  2018 ),  Zhang et al. (2018)  and  Das et al. (2018) , which consider the question answering task in a reinforcement learning setting in which the agent always chooses to answer. 1 Other approaches consider this as a link prediction problem in which multi-hop reasoning can be used to learn relational paths that link two entities. One line of work focuses on composing embeddings  (Neelakantan et al., 2015; Guu et al., 2015; Toutanova et al., 2016)  initially introduced for link prediction, e.g., TransE  (Bordes et al., 2013) , ComplexE  (Trouillon et al., 2016)  or ConvE  (Dettmers et al., 2018) . Another line of work focuses on logical rule learning such as neural logical programming  and neural theorem proving  (Rockt?schel and Riedel, 2017) . Here, we focus on question answering rather than link prediction or rule mining and use reinforcement learning to circumvent that we do not have ground truth paths leading to the answer entity. Recently, popular textual QA datasets have been extended with not-answerable questions  (Trischler et al., 2017; Rajpurkar et al., 2018) . Questions that cannot be answered are labeled with 'no answer' option which allows for supervised training. This is different from our setup in which there are no ground truth 'no answer' labels. 

 Background: Reinforcement learning We base our work on the recent reinforcement learning approaches introduced in  Das et al. (2018) and Lin et al. (2018) . We denote the knowledge graph as G, the set of entities as E, the set of relations as R and the set of directed edges L between entities of the form l = (e 1 , r, e 2 ) with e 1 , e 2 ? E and r ? R. The goal is to find an answer entity e a given a question entity e q and the question relation r q , when (e q , r q , e a ) is not part of graph G. We formulate this problem as a Markov Decision Problem (MDP)  (Sutton and Barto, 1998)  with the following states, actions, transition function and rewards: States. At every timestep t, the state s t is defined by the current entity e t , the question entity e q and relation r q , for which e t , e q ? E and r q ? R. More formally, s t = (e t , e q , r q ). Actions. For a given entity e t , the set of possible actions is defined by the outgoing edges from e t . Thus A t = {(r , e )|(e t , r , e ) ? G}. Transition function. The transition function ? maps s t to a new state s t+1 based on the action taken by the agent. Consequently, s t+1 = ?(s t , A t ) = ?(e t , e q , r q , A t ). Rewards. The agent is rewarded based on the final state. For example, in  Das et al. (2018) and Lin et al. (2018)  the agent obtains a reward of 1 if the correct answer entity is reached as the final state and 0 otherwise (i.e., R(s   2a  illustrates the LSTM which encodes history of the path taken. The output at timestep t is used as input to the policy network, illustrated in Figure  2b , to determine which action to take next. T ) = I{e T = e a }). LSTM . . . LSTM . . . LSTM h 1 h t?1 h t h T ?1 r 0 , e q r t , e t r T , e T (a) History LSTM FFNN (f ) r q , e t , h t r t+1,1 e t+1,1 . . . r t+1,|At| e t+1,|At| 

 Training We train a policy network ? using the REIN-FORCE algorithm of  Williams (1992)  which maximizes the expected reward: J(?) = E (eq,rq,ea)?G E a 1 ,...,a T ? [R(s T |e q , r q )] (1) in which a t is the action selected at timestep t following the policy ?, and ? are the parameters of the network. The policy network consists of two parts: a Long Short-Term Memory (LSTM) network which encodes the history of the traversed path, and a feed-forward neural network to select an action (a t ) out of all possible actions. Each entity and relation have a corresponding vector e t , r t ? R d . The action a t ? A t is represented by the vectors of the relation and entity as a t = [r t+1 ; e t+1 ] ? R 2d . The LSTM encodes the history of the traversed path and updates its hidden state each timestep, based on the selected action: h t = LST M (h t?1 , a t?1 ) (2) This is illustrated in Figure  2a . Finally, the feed-forward neural network (f ) combines the history h t , the current entity representation e t and the query relation r q . Using softmax, we compute the probability for each action by calculating the dot product between the output of f and each action vector a t :  ?(a t |s t ) = sof tmax(A t f (h t , e t , r q )) (3) in which A t ? 

 Evaluation User-facing question answering systems inherently face a trade-off between presenting an answer to a user that could potentially be incorrect, and choosing not to answer. However, prior work in knowledge graph question-answering (QA) only considers cases in which the answering agent always produces an answer. This setup originates from the link prediction and knowledge base completion tasks in which the evaluation criteria are hits@k and Mean Reciprocal Rank (MRR), where k ranges from 1 to 20. However, these metrics are not an accurate representation of practical question-answering systems in which the goal is to return a single correct answer or not answer at all. Moreover, using these metrics result in the problem of the model learning 'spurious' paths since the metrics encourage the models to make wild guesses even if the path is unlikely to lead to the correct answer. We therefore propose to measure the fraction of questions the system answers (Answer Rate) and the number of correct answers out of all answers (Precision) to measure the system performance. We combine these two metrics by taking the harmonic mean and call this the QA Score. This can be viewed as a variant of the popular F-Score metric, with answer rate used as an analogue to recall in the original metric. 

 Proposed method In this section, we will first introduce the supervised learning technique we used to pretrain the neural network before applying the reinforcement learning algorithm. Next we will describe the ternary reward structure. 

 Supervised learning Typically in reinforcement learning, the search space of possible actions and paths grows exponentially with the path length. Our problem is no exception to this. Hence an imitation learning approach could be beneficial here where we provide a number of expert paths to the learning algorithm to bootstrap the learning process. This idea has been explored previously in the context of link and fact prediction in knowledge graphs where  Xiong et al. (2017)  proposed to use a Breadth-First-Search (BFS) between the entity pairs to select a set of plausible paths. However BFS favours identification of shorter paths which could bias the learner. We therefore use Depth-First-Search (DFS) to identify paths between question and answer entities and sample up to 100 paths to be used for the supervised training. If no path can be found between the entity pair we return a 'no answer' label. Following this, we train the network using reinforcement learning algorithm which refines it further. Note that it is not guaranteed that the set of paths found using DFS are most efficient. However as we show in our experiments, bootstrapping with these paths provide good initialization for the reinforcement learning algorithm. 

 Ternary reward structure As mentioned previously, we encounter situations when the answer entity cannot be reached in the limited number of steps taken by an agent. In such cases, the system should return a special answer 'no answer' as the response. We can achieve this by adding a synthetic 'no answer' action that leads to a special entity e N OAN SW ER . This is illustrated in Figure  3 . In the framework of Das et al. (  2018 ) a binary reward is used which rewards the learner for the answer being wrong or correct. Following a similar protocol, we could award a score of 1 to return 'no answer' when there is no answer available in the KG. However, we cannot achieve reasonable training with such reward structure. This is because there is no specific pattern for 'no answer' that could be directly learned. Hence, if we reward a system equally for correct or no answer, it learns to always predict 'no answer'. We therefore propose a ternary reward structure in which a positive reward is given to a correct answer, a neutral reward when e N OAN SW ER is selected as an answer, and a negative reward for an Lives in 

 No answer Figure  3 : Fictional graph for the the question "What's the capital of France?". The relation (Capital of ) does not exist in the graph and thus an alternative path needs to be used that leads to the correct answer. To avoid that the agent returns an incorrect answer when not finding the correct answer, a 'no answer' relation is added between every entity node and a special 'no answer' node, to be able to return 'no answer'. incorrect answer. More formally: R(s T ) = ? ? ? ? ? r pos if e T = e a , 0 if e T = e N OAN SW ER , r neg if e T ? {e a , e N OAN SW ER } (4) with r pos >0 and r neg <0. The idea is that the agent receives a larger reward for a correct answer compared to not answering the question, and a negative reward for incorrectly answering a question compared to not answering the question. In the experimental section, we show that this mechanism provides better performance. 

 Experimental setup We evaluate our proposed approach on a publicly available dataset, FB15k-237  (Toutanova and Chen, 2015)  which is based on the Freebase knowledge graph and a proprietary dataset Alexa69k-378 which is a sample of Alexa's proprietary knowledge graph. Both the public dataset and the proprietary dataset are good examples of 

 Model Hits@1 Hits@10 MRR Precision Answer Rate QA Score  (Das et al., 2018)    

 Model Hits@1 Hits@10 MRR Precision Answer Rate QA Score  (Das et al., 2018)    real-world general-purpose knowledge graphs that can be used for question answering. FB15k-237 contains 14,505 different entities and 237 different relations resulting in 272,115 facts. Alexa69k-378 contains 69,098 different entities and 378 different relations resulting in 442,591 facts. We follow the setup of  Das et al. (2018) , using the same train/val/test splits for FB15k-237. For Alexa69k-378 we use 10% of the full dataset for validation and test. For both datasets, we add the reverse relations of all relations in the training set in order to facilitate backward navigation following the approach of previous work. Similarly, a 'no op' relation is added for each entity between the entity and itself, which allows the agent to loop/reason mul-tiple consecutive steps over the same entity. An overview of both datasets can be found in Table  3 . We extend the publicly available implementation of  Das et al. (2018)  for our experimentation. We set the size of the entity and relation representations d at 100 and the hidden state at 200. We use a single layer LSTM and train models with path length 3 (tuned using hyper-parameter search). We optimize the neural network using Adam  (Kingma and Ba, 2015)  with learning rate 0.001, mini-batches of size 256 with 20 rollouts per example. During the test time, we use beam search with the beam size of 100. Unlike  Das et al. (2018) , we also train entity embeddings after initializing them with random values. Reward values are set as r pos = 10 and r neg = ?0.1 after performing a coarse grid search for various reward values on the validation set. For all experiments, we selected the best model with the highest QA Score on the corresponding validation set. 

 Results The results of our experiments for FB15k-237 and Alexa69k-378 are given in Table  1 and Table 2 re spectively. Supervised learning For FB15k-237, we see that the model trained using reinforcement learning (RL) scores as well as the model trained using supervised learning. This makes supervised learning using DFS a strong baseline system for question answering over knowledge graphs, and for FB15k-237 in particular. On Alexa69k-378, models trained using supervised learning score lower on all metrics compared to RL. When combining supervised learning with RL overall performance increases. No answer When we train RL system with our ternary reward structure (No Answer RL), the precision and QA score increase significantly on both datasets. For FB15k-237, our No Answer RL model decided not to answer over 40% of the questions, with an absolute hits@1 reduction of only 1.3% over standard RL. Moreover, of all the answered questions, 40.11% were answered correctly compared to 24.75% of the original question-answering system: an absolute improvement of over 15%. This resulted in the final QA Score of 47.58%, around 8% higher than standard RL and 12% higher than  Das et al. (2018) . Similarly, 60% of the questions did not get answered on Alexa69k-378. This resulted in hits@1 decrease of roughly 1% but compared to standard RL, the precision increased from 16.77% to 38.92%: an absolute increase of more than 20%. The final QA Score also increased from 28.72% to 39.55%, and also significantly improved over  Das et al. (2018) and Lin et al. (2018) . The results indicate that using our method allows us to improve the precision of the question-answering system by choosing the right questions to be answered by not answering many questions that were previously answered incorrectly. This comes at the expense of not answering some questions that previously could be answered correctly. All Finally, all methods were combined in a single method. First the model was pretrained in a supervised way. Then the model was retrained using RL algorithm with ternary reward structure. This jointly trained model obtained better QA scores than any individually trained model. On FB15k-237, a QA score of 52.16% is obtained which is an absolute improvement of 4.58% over the best individual model and 2.66% over  Lin et al. (2018) . Similarly, on Alexa69k-378, an absolute improvement of 2.57% over the best individual result is obtained, almost 10% absolute improvement over  Lin et al. (2018) . Sample results from our method are given in Table  4 and Table 5 . Reward tuning An important part of increasing the QA score is to select the right combination of rewards. Therefore, we ran additional experiments where we varied either the positive or negative reward, keeping the other rewards fixed. In Figure  4 , the precision, answer rate and QA score are shown when varying the positive reward and keeping the neutral and negative rewards fixed. When, the positive reward is very small (r pos = 0.625), almost no question is answered. When the positive reward r pos is 1.25, roughly 20% of the questions are answered with a 50% precision. After that, the precision starts declining and the answer rate France 

 Figure2: Figure2aillustrates the LSTM which encodes history of the path taken. The output at timestep t is used as input to the policy network, illustrated in Figure2b, to determine which action to take next. 

 France 

 Figure 4 :Figure 5 : 45 Figure 4: Influence of changing the positive reward for FB15k-237. The negative reward is fixed at r neg = ?0.1 and the neutral reward is fixed at r neutral = 0. 

 Table 1 : 1 Results on FB15k-237 dataset. 0.217 0.456 0.293 0.217 1 0.357 (Lin et al., 2018) 0.329 0.544 0.393 0.329 1 0.495 RL 0.2475 0.4032 0.2983 0.2475 1 0.3968 Supervised 0.2474 0.4929 0.3276 0.2474 1 0.3967 Supervised + RL 0.2736 0.5015 0.3469 0.2736 1 0.4296 No Answer RL 0.2345 0.3845 0.2831 0.4011 0.5847 0.4758 All 0.2738 0.4412 0.3286 0.4835 0.5663 0.5216 

 Table 2 : 2 Results on Alexa69k-378 dataset. 0.1790 0.2772 0.2123 0.1790 1 0.3036 (Lin et al., 2018) 0.1915 0.3184 0.2358 0.1915 1 0.3214 RL 0.1677 0.2716 0.2031 0.1677 1 0.2872 Supervised 0.1471 0.3142 0.203 0.1471 1 0.2565 Supervised + RL 0.1937 0.3045 0.2312 0.1937 1 0.3245 No Answer RL 0.1564 0.2442 0.1858 0.3892 0.4019 All 0.1865 0.294 0.2229 0.3454 0.5401 0.4213 #queries #ent #rel #facts valid test FB15k-237 14,505 237 272,115 17,535 20,466 Alexa69k-378 69,098 378 442,591 55,186 55,474 

 Table 3 : 3 Statistics of the datasets. 

			 An initial version of this paper has been presented at the Relational Representation Learning Workshop at NeurIPS 2018 as Godin et al. (2018) .
