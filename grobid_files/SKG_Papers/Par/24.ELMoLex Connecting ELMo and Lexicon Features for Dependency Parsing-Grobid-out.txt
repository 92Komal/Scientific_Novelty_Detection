title
ELMoLex: Connecting ELMo and Lexicon features for Dependency Parsing

abstract
In this paper, we present the details of the neural dependency parser and the neural tagger submitted by our team 'ParisNLP' to the CoNLL 2018 Shared Task on parsing from raw text to Universal Dependencies. We augment the deep Biaffine (BiAF) parser  (Dozat and Manning, 2016)  with novel features to perform competitively: we utilize an indomain version of ELMo features  (Peters et al., 2018)  which provide contextdependent word representations; we utilize disambiguated, embedded, morphosyntactic features from lexicons (Sagot, 2018), which complements the existing feature set. Henceforth, we call our system 'ELMoLex'. In addition to incorporating character embeddings, ELMoLex leverage pre-trained word vectors, ELMo and morphosyntactic features (whenever available) to correctly handle rare or unknown words which are prevalent in languages with complex morphology. EL-MoLex 1 ranked 11 th by Labeled Attachment Score metric (70.64%), Morphology-aware LAS metric (55.74%) and ranked 9 th by Bilexical dependency metric (60.70%). In an extrinsic evaluation setup, ELMoLex ranked 7 th for Event Extraction, Negation Resolution tasks and 11 th for Opinion Analysis task by F1 score.

Introduction The goal of this paper is to describe ELMoLex, the parsing system submitted by our team 'ParisNLP' to the CoNLL 2018 Shared Task on parsing from raw  1  Code to reproduce our tagging and parsing experiments is publicly accessible at https://github.com/ BenjaminMullerGit/NeuroTaggerLex and https: //github.com/ganeshjawahar/ELMoLex respectively. text to Universal Dependencies  (Zeman et al., 2018) . The backbone of ELMoLex is the BiAF parser  (Dozat and Manning, 2016)  consisting of a large, well-tuned network that generates word representations, which are then fed to an effective, biaffine classifier to predict the head of each modifier token and the class of the edge connecting these tokens. In their follow-up work  (Dozat et al., 2017) , the authors further enrich the parser by utilizing character embeddings for generating word representations which could help in generalizing to rare and unknown words (also called Out Of Vocabulary (OOV) words). They also train their own taggers using a similar architecture and use the resulting Part of Speech (PoS) tags for training the parser in an effort to leverage the potential benefits in PoS quality over off-the-shelf taggers. We identify two potential shortcomings of the BiAF parser. The first problem is the context independence of the word embedding layer of the parser: the meaning of a word varies across linguistic contexts, which could be hard to infer automatically for smaller treebanks (especially) due to lack of data. To handle this bottleneck, we propose to use Embeddings from Language Model (ELMo) features  (Peters et al., 2018)  which are context dependent (function of the entire input sentence) and obtained from the linear combination of several layers of a pre-trained BiLSTM-LM 2 . The second problem is the linguistic naivety 3 of the character embeddings: they can generalize over relevant sub-parts of each word such as prefixes BiAF y  (arc)  y  (rel)  x  (GP)  . . . or suffixes, which can be problematic for unknown words which do not always follow such generalizations  (Sagot and Mart?nez Alonso, 2017) . We attempt to lift this burden by resorting to external lexicons 4 , which provides information for both word with an irregular morphology and word not present in the training data, without any quantitative distinction between relevant and less relevant information. To tap the information from the morphological features (such as gender, tense, mood, etc.) for each word present in the lexicon efficiently, we propose to embed the features and disambiguate them contextually with the help of attention  (Bahdanau et al., 2014) , before combining them for the focal word. We showcase the potential of ELMoLex in parsing 82 treebanks provided by the shared task. ELMoLex ranked 11 th by Labeled Attachment Score (LAS) metric (70.64%), Morphology-aware LAS (MLAS) metric (55.74%) and ranked 9 th by BiLEXical dependency (BLEX) metric (60.70%). We perform ablation and training time studies to have a deeper understanding of ELMoLex. In an extrinsic evaluation setup  (Fares et al., 2018) , ELMoLex ranked 7 th for Event Extraction, Negation Resolution tasks and 11 th for Opinion Analysis task by F1 score. On an average, ELMoLex ranked 8 th with a F1 score of 55.48%. 

 ELMoLex The model architecture of ELMoLex, which uses BiAF parser  (Dozat and Manning, 2016)  (which in turn is based on  Kiperwasser and Goldberg (2016) ) as its backbone, is displayed in Figure  1 . For our shared task submission, we assume tokenization and segmentation is already done 5 ; we henceforth train ELMoLex on gold tokens and PoS tags provided by UDPipe  (Straka et al., 2016) . We evaluate our model using the segmentation and PoS tags provided by UD-Pipe, except for certain languages where we use the tokens and PoS tag predicted by our own tokenizer and taggers (as respectively explained in Section 2.6 and 2.7) 6 respectively. 

 Backbone parser ELMoLex uses the BiAF parser  (Dozat and Manning, 2016) , a state-of-the-art graph-based parser, as its backbone. BiAF parser consumes a sequence of tokens and their PoS tags, which is fed through a multilayer BiLSTM network. The output state of the final LSTM layer is then fed through four separate ReLU layers, producing four specialized vector representations: first for the word as a modifier seeking its head; second for the word as a head seeking all its modifiers; third for the word as a modifier deciding on its label; and lastly for the word as head deciding on the labels of its modifiers. These vectors become the input to two biaffine classifiers: one computes a score for each token pair, with the highest score for a given token indicating that token's most probable head; the other computes a score for each label for a given token/head pair, with the highest score representing the most probable label for the arc from the head to the Figure  2 : Architecture of embedding model used by ELMoLex for the word 'admonish'. v  GP (ELM o)  and v  GP (lex)  (red ellipses) are our major contributions. Arrows indicate structural dependence, but not necessarily trainable parameters. modifier. We refer the readers to  Dozat and Manning (2016)  for further details. Formally, the BiAF parser consumes a sequence of n word embeddings (v GP (word) 1 respectively. Note that '+' denotes element-wise addition operator, while '?' denotes concatenation operator. ELMoLex reformulates the input embedding layer of BiAF parser in a few ways (as illustrated in Figure  2 ): we utilize an indomain version of ELMo features (v GP (ELM o) i ) which provide context-dependent word representation (as discussed in Section 2.2); we utilize disambiguated, embedded, morphosyntactic features from lexicons (v GP (lex) i ), which provide information that is especially relevant for word with an irregular morphology  (Sagot and Mart?nez Alonso, 2017) , thereby complementing the existing feature set (as discussed in Section 2.3). Incorporating them, equation 1 now becomes: x GP i = v GP (word) i ? v GP (morph) i , v GP (word) i = v GP (f air) i ? v GP (char) i ? v GP (ELM o) i , v GP (morph) i = v GP (P oS) i ? v GP (lex) i , v GP (P oS) i = v GP (U P oS) i + v GP (XP oS) i . (2) In the equation 2, v GP (f air) i and v GP (char) i represent the learnable embeddings that are associated with frequent words in the vocabulary (pre-initialized from FAIR word vectors  (Bojanowski et al., 2017) ) and convolution-based character-level embeddings  (Ma et al., 2018)  7 respectively. Apart from these changes in the embedding layer, we replace the decoding strategy (tree construction from the predicted graph) of our parser from greedy decoding (used by BiAF parser) to Chu-Liu-Edmonds algorithm  (Chu and Liu, 1967) , which further improves performance during evaluation. 

 ELMo features In natural language, the meaning of a word changes when the underlying linguistic context changes. This fact is not captured by static word embeddings due to their context independence. Employing a deep, contextualized word representation, ELMo  (Peters et al., 2018) , which is a function of the entire sentence, yields promising result for several downstream tasks such as Question Answering, Textual Entailment and Sentiment Analysis. We attempt to test whether this hypothesis holds for dependency parsing. This is an interesting experiment as the authors of ELMo obtain larger improvements for tasks with small train set (sample efficient), indicating that smaller treebanks deprived of useful information could potentially enjoy good improvements.  8  The backbone of ELMo is a BiLSTM-based neural Language Model (BiLSTM-LM), which is trained 226 on a large raw corpus. We attempt to explore in this work whether we can train an indomain version of a BiLSTM-LM effectively using the available training data. The main challenge to accomplish this task is to learn transferable features in the absence of abundant raw data. Inspired by the authors of BiAF who use a large, well-tuned network to create a high performing graph parser, we implement a large BiLSTM-LM network (independent of the ELMoLex parser) which is highly regularized to prevent data overfitting and able to learn useful features. Our BiLSTM-LM consumes both the word and tag embedding as input, which can be formally written as: x LM i = v LM (word) i ? v LM (U P oS) i , v LM (word) i = v LM (f air) i ? v LM (char) i . (3) In equation 3, the notations v LM (f air) i , v LM (char) i and v LM (U P oS) i are the counterparts of v GP (f air) i , v GP (char) i and v GP (U P oS) i respectively. Note that ELMo, as proposed in  Peters et al. (2018) , builds only on character embeddings, automatically inferring the PoS information in the lower layers of the LSTM network. Since we have less training data to work with, we feed the PoS information explicitly which helps in easening the optimization process of our BiLSTM-LM network. Given a sequence of n words, x LM 1 , . . . , x LM n , BiLSTM-LM learns by maximizing the log likelihood of forward LSTM and backward LSTM directions, which can be defined as: n ? i=1 (log Pr(x LM i |x LM 1 , . . . , x LM i?1 ; ?x; ? ? ? LST M , ? ? ? s)) + (log Pr(x LM i |x LM i+1 , . . . , x LM n ; ?x; ? ? ? LST M , ? ? ? s)) . (4) We share the word embedding layer (? x ) of both LSTMs and learn the rest of the parameters independently. Unlike  Peters et al. (2018) , we do not tie the Softmax layer (? s ) in both the LSTM directions. Essentially, ELMo features are computed by a taskspecific linear combination of the BiLSTM-LM's intermediate layer representations. If L represents the number of layers in BiLSTM-LM, ELMo computes a set of 2L + 1 representations: R k = {x LM k , ? ? h LM k,j , ? ? h LM k,j |j = 1, . . . , L} = {h LM k,j |j = 1, . . . , L}, (5) where h LM k,0 is the word embedding layer (Equation  3 ) and h LM k,j = ? ? h LM k,j ? ? ? h LM k,j , for each BiLSTM layer. The authors of ELMo  (Peters et al., 2018)  show that different layers of BiLSTM-LM carry different types of information: lower-level LSTM states capture syntactic aspects (e.g., they can be used for PoS tagging); higher-level LSTM states model context-dependent aspects of word meaning (e.g., they can be used for word sense disambiguation); This observation is exploited by ELMoLex which can smartly select among all of these signals the useful information for dependency parsing. Thus, ELMo features for a word are computed by attending (softly) to the informative layers in R, as follows: v GP (ELM o) i = E(R k ; ? elmo ) = ? elmo L ? j=0 s elmo j h LM k,j . (6) In equation 6, s elmo corresponds to the softmaxnormalized weights, while ? elmo lets ELMoLex to scale the entire ELMo vector. 

 Lexicon features Character-level models depend on the internal character-level make-up of a word. They exploit the relevant sub-parts of a word such as suffixes or prefixes to generate word representations. They can generalize to unknown words if these unknown words follow such generalizations. Otherwise, they fail to add any improvement  (Sagot and Mart?nez Alonso, 2017)  and we may need to look for other sources to complement the information provided by characterlevel embeddings. We term this problem as linguistic naivety. ELMoLex taps into the large inventory of morphological features (gender, number, case, tense, mood, person, etc.) provided by external resources, namely the UDLexicons  (Sagot, 2018)  lexicon collection, which cover words with an irregular morphology as well as words not present in the training data. Essentially, these lexicons consist of ?word, UPoS, morphological features? triplets, which we query using ?word, UPoS? pair resulting in one or more hits. When we attempt to integrate the information from these hits, we face the challenge of disambiguation as not all the morphological features returned by the query are relevant to the focal ?word, UPoS? pair. ELMoLex relies on attention mechanism  (Bahdanau et al., 2014)  to select the relevant morphological features, thereby having the capability to handle noisy or irrelevant features by paying no attention. Put formally, given a sequence of m morphological feature embeddings (v GP (mf ) mf 1 , ?, v GP (mf ) mfm ) for a word i, the lexicon-based embedding for the word (v GP (lex) i ) can be computed as follows: 9 v GP (lex) i = m ? j=1 s lex mf j v GP (mf ) mf j . ( 7 ) In equation 7, s lex mf j corresponds to the softmaxnormalized weight which is a learnable parameter for each available morphological feature (in this case, it is mf j ). The general idea to perform a weighted sum to extract relevant features has been previously studied in the context of sequence labeling  (Rei et al., 2016)  for integrating word and character level features. Combining the distributional knowledge of words along with the semantic lexicons has been extensively studied for estimating high quality word vectors, also referred to as 'retrofitting' in literature  (Faruqui et al., 2015) . 

 Delexicalized Parsing We perform delexicalized "language family" parsing for treebanks with less than 50 or no train sentences (as shown in Table  1 ). The delexicalized version of ELMoLex throws away word-level information such as v  GP (word)  and v  GP (char)  and works with the rest. The source treebanks are concatenated to form one large treebank, which is then used to train the delexicalized parser for the corresponding target treebank. In case of "mixed model", we concatenate at most 300 sentences from each treebank to create the training data. 

 Handling OOV words Out Of Vocabulary (OOV) word problem is prevalent in languages with rich morphology and an accurate parser should come up with smart techniques to perform better than substituting a learned unknown vocabulary token ('UNK') during evaluation. To circumvent this problem, ELMoLex relies on four signals from the proposed embedding layer: ? v GP (f air) : If an OOV word is present in the FAIR word vectors, ELMoLex directly substitute the word embedding without any transformation.  10  If OOV word is absent, we resort to using 'UNK' token. ? v  GP (ELM o)  : For an OOV word, the ELMo layer of ELMoLex computes the context-dependent word representation based on the other vocabulary words present in the focal sentence. ? v  GP (char)  : Character-level embedding layer of ELMoLex computes the representation based on the known characters extracted from the OOV word naturally. ? v  GP (lex)  : If an OOV word is present in the external lexicon, ELMoLex queries with the ?word, PoS? pair and computes the representation based on the known set of morphological features. 

 Neural Tagger with embedded lexicon As described in  Dozat et al. (2017) , the BiAF model benefits from Part-of-Speech (PoS) inputs only if their accuracy is high enough. Our idea was therefore to design an accurate tagger in order to improve the performance of the parser. Moreover, the shared task allows the use of external resources such as lexicons. A lexicon is simply a collection of possibilities in terms of PoS and morphological features usually provided for a large amount of words. In the context of neural taggers, an external lexicon can be seen as an external memory that can be useful in two ways: ? For making training faster. At initialization, for a given token, all possible PoS tags are equiprobable of being predicted by the network. The model only learns from the example it sees. By providing the model with a constrained set of possible tags as input features we can expect the training process to be faster. ? For helping the model with OOV tokens. Indeed, the lexicon provides information -potentially complementary to the character based representation -on OOV tokens that could be useful at inference. Generally speaking, this experience is interesting because it challenges the idea that neural models, if deep enough and trained on enough data, don't require external resources and can learn everything in an endto-end manner. As we will see for tagging, external pre-computed resources such as lexicons are of a great help. The tagger we design is based on the neural tagging model with lexicon described in Sagot and Mart?nez Alonso (2017) and adapted using architectural insights from  Dozat and Manning (2016) . In short, words are represented in three ways. The first part is a trainable word vector (initialized with the FAIR vectors described in  Bojanowski et al. (2017) ). The second part is a character-based representation either computed using 1-dimensional convolution or a recurrent LSTM cell. The third component is an n-hot encoded vector of the tags that appear in an external lexicon, possibly embedded in a continuous space. These three components are summed, providing a morphologically and lexically-enriched word representation. This vector is then fed to a two layer BiLSTM that encodes the sentence level context, followed by two heads, one for predicting UPoS and the other for predicting morphological features. Each head is composed of a dense layer followed by a softmax layer. 

 Specific Tokenization post-processing for Arabic To improve the Arabic tokenizer, we noticed that tokenization is very error-prone wherein most of the errors come from wrong analysis of the letter ?.'?'? Indeed, in Arabic, this letter (which is a coordinate conjunction, "and") is usually concatenated to the next word (e.g ' ?,'? "and Qata") but is sometimes just a part of the word (e.g ?,'?'? "he agrees"). This ambiguity confuses the UDPipe tokenizer. Our fix consists in splitting that letter from its word whenever UDPipe was unable to provide a proper UPoS tag. This simple fix led to a 0.7% improvement in word segmentation compared to the UDPipe baseline and led us to rank 4 th on Arabic in the final LAS metric.  

 Results The implementation of ELMoLex as well as the neural tagger are based on the publicly available BiAF parser code provided by CMU  (Ma et al., 2018) . Similar to  Dozat et al. (2017) , we use mostly the same set of hyper-parameters (as displayed in Appendix A), which makes ELMoLex robust across a wide variety of treebanks present in the shared task  (Zeman et al., 2018) . For treebanks with no development data, we perform a 5-fold cross validation to identify the average number of epochs taken to train each fold. By setting the maximum number of epochs to this average number, we then train ELMoLex on 90% of the training data and use the rest of the training data for selecting our best model. When we do not find external lexicon in UDLexicons  (Sagot, 2018)  for a given language, we skip the lexicon based features (v GP (lex) ) and work with the rest. ELMoLex ran for ?26 hours on the TIRA virtual machine  (Potthast et al., 2014)  sequentially, which can be trivially parallelized to run within two hours. Our shared task results are displayed in Appendix B. 

 Performance Analysis of the Tagger Given the general architecture we presented in Section 2.6, we are able to test a few key questions: Is recurrent cell better suited at encoding word morphology compared to 1-D convolution layer ? Is embedding the lexical information into a continuous space useful for improving the performance ? And finally, is using an external lexicon always useful for better UPoS tagging ? We summarize our results as follows: ? Convolution layer works better than recurrent cell for languages such as Vietnamese and Chinese. ? Leveraging an external lexicon helps the tagger for most of the languages, specifically for languages such as French (tested on f r_sequoia Table  3 : Ablation study of ELMoLex. LAS dev. score along with training time (with 90% of the training data with the rest used for selecting the best model) in minutes is reported for selected treebanks. For NLM Init. and ELMoLex models, we report the time taken to train the parser (excluding the time taken to train the underlying BiLSTM-LM). All the reported models uses Chu-Liu-Edmonds algorithm  (Chu and Liu, 1967)  for constructing the final parse tree. and f r_spoken), Greek, Danish, Hungarian and Swedish. The only language for which the lexicon did not help is Turkish. ? Using a continuous embedding layer for lexicon features always leads to better performance compare to straight n-hot encoding. We now present in more details the performance of our model regarding these three dimensions. The results are reported on development datasets treated as a strict test set. As we notice in Figure  3 , using a convolution layer as a morphological embedding technique provides poorer results compared to a recurrent cell except for two cases: Chinese and Vietnamese. This suggests that the different morphology and tokenization complexity that we find for Europeans languages compared to Chinese and Vietnamese might well require different kind of embedding architectures. Intuitively, we could say that the character-wise sequential structure of the Europeans languages is better modeled by a recurrent cell, while a language like Chinese with overlaying phenomenons is better modeled by a convolution layer. We now describe the impact of an external lexicon for UPoS tagging (Figure  . 4 ). We present the results only for the datasets for which the RNN cell was providing the best results. We compare two architectures: the neural tagger using a recurrent cell for morphology with an external lexicon (embedded in a continuous space) and the same architecture without external lexicons. For all the treebanks (except Turkish), the lexicon helps the UPoS tagging performance. The last component of the neural tagger we analyze is the input technique of the lexical information. We compare two techniques. The first one is the architecture described in  Sagot and Mart?nez Alonso (2017)  for which the lexical information is feeded using a nhot encoded vector which is then concatenated with the other word representation vectors. The second one embeds in a continuous space the lexicon tags before averaging them providing a single vector that summarizes the lexical information of a given word. As we see in Figure  5 , in all languages we experimented with, the embedding layers provides better results than a simple n-hot encoded representation. For most of the treebanks, we performed significantly above the UDPipe baseline for UPoS tagging. Our results are summarized in Table  2 . Unfortunately, we reached these results too late before the deadline, and we did not get the time to retrain our parser on our own, predicted PoS tags. Therefore, at test time, we only used the predicted tags for treebanks for which we were confident that our predicted tags would help the parser. It resulted in using our system for four treebanks: el_gdt, hu_szeged, sv_lines and tr_imst. In Appendix C,you will find the performance of our Neural tagger and our ELMoLex parser trained on our predicted tags for which we were able to retrain the models after the system submission deadline. 

 Ablation Study of the Parser To unpack the benefits obtained from each of our contributions, we perform ablation studies with the following variants of ELMoLex: ELMoLex without ELMo and lexicon features, which is effectively the vanilla BiAF model  (Ma et al., 2018)  The results are displayed in Table  3  12 . We make the following important observations: (1) Utilizing either ELMo or Lexicon or both always outperform the BiAF model; (2) External lexicons brings in valuable information about OOV words and words with irregular morphology, thereby outperforming BiAF (which relies for those cases on character embeddings only) by a large margin; (3) ELMo entails high train time due to the additional LSTM operation over the entire  11  Our final submission to the shared task did not have the NLM pre-initialization feature.  12  The training time reported in the table is an over-estimate, as it is captured when several parsers (at most four of them) are running together in a single GTX 1070 GPU. sentence, but exhibits strong performance over BiAF model which naturally leads us to combine it along with the lexicon information to create ELMoLex (our final submission system). In summary, in contrast with our participation to the shared task last year (de La Clergerie et al. (  2017 )  13  , we decided to focus on neural models wherein we explored many architectures and ideas both for tagging and parsing. As a result we reached superior performance in the final LAS score compared to our last year submission. To illustrate this, we compare the results of our current submission with that of the last year for four treebanks (Table  4 ) and observe significant improvements in the LAS score. 

 Extrinsic Evaluation of the Parser A "good" parser should not only perform well in the intrinsic metrics such as LAS, BLAS and BLEX, but should strengthen a real world NLP system by providing relevant syntactic features. To understand the impact of ELMoLex in a downstream NLP application, we participiated in the shared task on Extrinsic Parser Evaluation  (Fares et al., 2018) . The goal of this task is to evaluate the parse trees predicted by ELMoLex on three downstream applications: biological event extraction, fine-grained opinion analysis, and negation resolution, for its usefulness. Since all the tasks are based on English language, we train ELMoLex on en_ewt treebank (which is the largest English treebank provided by the organizers  (Zeman et al., 2018) ) without changing the hyper-parameters (as disclosed in Appendix A). We refer the readers to  Fares et al. (2018)  for details about each of the downstream task and the accompanying system (which takes the features dervied from ELMoLex) used to solve the task. Our extrinsic evaluation results 14 are displayed in Table 5. ELMoLex ranked 7 th for Event Extraction, Negation Resolution tasks and 11 th for Opinion Analysis task by F1 score. On an average, ELMoLex Table  5 : Results on the downstream tasks for our ELMoLex system trained on the en_ewt treebank with the corresponding difference from the best system enclosed in ellipses. ranked 8 th with a F1 score of 55.48%. 

 Conclusion We presented our parsing system, ELMoLex, which successfully integrates context-dependent ELMo and lexicon-based representations to overcome the context independency and linguistic naivety problem in the embedding layer of the BiAF model respectively. We showed the analysis of our neural tagger, whose competitive performance in PoS estimation is capitalized by ELMoLex to achieve strong gains in parsing quality for four treebanks. We also performed an ablation study to understand the source of gains brought by ELMoLex. We evaluated ELMoLex on three downstream applications to understand its usefulness. In the next step of our work, we plan to: (1) compare the performance in utilizing recurrent layer over the convolution layer for character embeddings (similar to our neural tagger experiment) which underlies our parser; (2) pursue the NLM initialization feature further to inspect if using it can enrich ELMoLex; (3) observe the performance when we augment the indomain train data for our BiLSTM-LM with massive raw data (such as Wikipedia); (4) train our parser and tagger jointly with the gold PoS tags; and (5) exploit lattice information  (More et al., 2018; Buckman and Neubig, 2018)     8 : Performance of ELMOLEX trained and tested using tags from the neural tagger (with the corresponding absolute difference from our submission final results) and average absolute gain of using the neural tagger compared to tags used at the submissions **indicates datasets for which tags from the neural tagger where used at test time for the submission Figure 1 : 1 Figure 1: Architecture of ELMoLex which uses BiAF parser as its backbone. Arrows indicate structural dependence, but not necessarily trainable parameters. 
