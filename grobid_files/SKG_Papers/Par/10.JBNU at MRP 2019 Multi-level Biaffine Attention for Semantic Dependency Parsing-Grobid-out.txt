title
JBNU at MRP 2019: Multi-level Biaffine Attention for Semantic Dependency Parsing

abstract
This paper describes Jeonbuk National University (JBNU)'s system for the 2019 shared task on Cross-Framework Meaning Representation Parsing (MRP 2019) at the Conference on Computational Natural Language Learning. Of the five frameworks, we address only the DELPH-IN MRS Bi-Lexical Dependencies (DP), Prague Semantic Dependencies (PSD), and Universal Conceptual Cognitive Annotation (UCCA) frameworks. We propose a unified parsing model using biaffine attention (Dozat and Manning, 2017), consisting of 1) a BERT-BiLSTM encoder and 2) a biaffine attention decoder. First, the BERT-BiLSTM for sentence encoder uses BERT to compose a sentence's wordpieces into word-level embeddings and subsequently applies BiLSTM to word-level representations. Second, the biaffine attention decoder determines the scores for an edge's existence and its labels based on biaffine attention functions between roledependent representations. We also present multi-level biaffine attention models by combining all the role-dependent representations that appear at multiple intermediate layers.

Introduction Recent studies on meaning representation parsing (MRP) have focused on different semantic graph frameworks such as bilexical semantic dependency graphs  (Peng et al., 2017; Wang et al., 2018; Dozat and Manning, 2018) , universal conceptual cognitive annotation  (Hershcovich et al., 2017 (Hershcovich et al., , 2018 , and abstract meaning representation  (Wang and Xue; Guo and Lu; Song et al., 2019; . To jointly address various semantic graphs, the aim of the Cross-Framework MRP task  (MRP 2019)  at the 2019 Conference on Computational Natural Language Learning (CoNLL) is to develop semantic graph parsing across the following five frameworks : 1) DM: DELPH-IN MRS Bi-Lexical Dependencies  (Ivanova et al., 2012) , 2) PSD: Prague Semantic Dependencies  (Haji? et al., 2012; , 3) EDS: Elementary Dependency Structures  (Oepen and L?nning, 2006) , 4) UCCA: Universal Conceptual Cognitive Annotation  (Abend and Rappoport, 2013) , and 5) AMR: Abstract Meaning Representation  (Banarescu et al., 2013) . One of the main aims of MRP 2019 is to indduce a unified parsing model for different semantic frameworks such that parsing models can be trained using multi-task learning or transfer learning. To enable multi-task learning, we explicitly make shared common components in a neural network architecture across different frameworks. For MRP 2019, we propose a unified neural model for the DM/PSD/UCCA frameworks based on the biaffine attention used in  Manning, 2017, 2018;  by deploying the sentence encoder part as a "shared" component across these three frameworks. Our system consists of two main components: 1. BERT-BiLSTM sentence encoder (shared across frameworks): Given a sentence, the BERT encoder  (Devlin et al., 2019)  encodes to its wordpieces and the encoded word piece-level represenations are composed into word-level embeddings based on BiLSTM. Another BiLSTM layer is then applied to the resulting word-level embeddings to create the final sentence representations. We refer to this neural layer for encoding sentences as the BERT-BiLSTM sentence encoder. For multitask learning, the BERT-BiLSTM sentence encoder is shared across all target frameworks. 2. Biaffine attention decoder (frameworkspecific): Role-dependent representations for each word are first induced from the sentence-level embeddings of the BERT-BiLSTM encoder using simple feed-forward layers. Biaffine attention is then performed on the resulting role-dependent representations to predict the existence of an edge and its labels. However, the biaffine attention decoder is not shared but separately trained for each framework. Thus, we have three different biaffine decoders corresponding to DM, PSD, and UCCA. In addition, our system handles the following specific issues for UCCA parsing and node property prediction: 1. UCCA parsing using biaffine attention To handle UCCA formats using a biaffine attention model, we convert a UCCA graph to a bilexical framework using the semstr tool, which is based on the head rules of UCCA in  (Hershcovich et al., 2017 ). 1 After the biaffine attention is performed, the parsed bilexical graph is converted back to the UCCA format. 2. BiLSTM neural models for node property prediction: In addition to predicting the existence and labels of an edge, the system is required to predict node properties (for DM and PSD). To handle node properties, we further develop property-specific BiLSTMbased neural models. 2 These propertyspecific neural components are designed in a framework-specific manner and are not shared across frameworks. Furthermore, we present multi-level biaffine attention models, motivated by the multi-level architecture of FusionNet in the machine reading comprehension task . The preliminary unofficial experiments using our own development seting show that multi-task learning is helpful in improving UCCA's performance, but it does not lead to improvement in performances on the DM and PSD frameworks. We first converted a UCCA MRP format to its xml format and then applied the converter (semstr/convert.py) in semstr to obtain its CoNLL format: https://github.com/danielhers/semstr 2 The node properties required for DM and PSD are a POS tag and a frame. We prepared a BiLSTM neural model for predicting the frame information of a node only, whereas we used the companion data of MRP 2019 to predict POS tags. The remainder of this paper is organized as follows: Section 2 presents our system architecture with details, Section 3 describes the detailed process for training biaffine attention models. Section 4 and 5 provide the preliminary experiment results and the official results at MRP 2019, respectively, and our concluding remarks and a description of future work are given in Section 6. 

 Model Figure  1  shows the neural architecture based on biaffine attention for bilexical semantic dependency parsing. The neural architecture consists of two components: 1) the BERT-BiLSTM encoder and 2) the biaffine attention decoder. 1) In BERT-BiLSTM encoder, an input sentence is fed to a word representation layer using BERT, resulting in a sequence of word embedding vectors, which are then given to the BiLSTM layer to produce a sentence representation. 2) In biaffine attention, additional feed-forward layers are applied to obtain role-dependent representations for head and dependent roles, which are then forwarded to the biaffine attention. 

 Encoder: BERT-BiLSTM 

 Word representation layer using BERT The word representation using BERT uses BiL-STM for composing to word-level embeddings from wordpiece-level embeddings, similar to , which used the average pooling for composition. Specifically, suppose that an input sentence consists of n words, i.e., x 1 ? ? ? x n . To obtain the word representation x i for x i , we use BERT from  (Devlin et al., 2019)   pieces and they are fed to the BERT encoder. The resulting output from BERT, which consists of the word pieces in the i-th word are aggregated using BiLSTM, producing w bert i , named BERT wordlevel embedding.  3  The BERT word-level embedding is further combined with the pretrained GloVe word embedding of  (Pennington et al., 2014)  and part-ofspeech (POS) tag embedding to produce the final word representation, as follows: x i = w bert i ; e glove i ; e P OS i where e glove i and e P OS i denote the pretrained GloVe word embedding and the POS tag embedding for the i-th word, respectively. 

 BiLSTM sentence encoding layer Once word representations are obtained, we further apply BiLSTM to x 1 ? ? ? x n to obtain the following initial hidden representation of the i-th word: r i = BiLST M i (x 1 ? ? ? x n ) where BiLST M i refers to the i-th hidden representation obtained by applying BiLSTM to a given sequence. 

 Decoder: Biaffine attention To formulate a decoder using biaffine attention, let BiAf f (x, y) be a biaffine function using the notations of  (Dozat and Manning, 2018)  and  (Socher et al., 2013)  as follows: BiAf f m (x, y) = x T U [1:m] y + V x y + b where U [1:k] ? R d?d?m is a tensor, x T U [1:m] y produces vector r ? R k , V ? R m?d is a matrix and b ? R m is a vector for the bias term. Our biaffine attention decoder is similar to that of  (Dozat and Manning, 2018)  and is formulated as follows: F F N (x) = f (Ax + b) h (head) i = F F N (head) (r i ) h (dep) i = F F N (dep) (r i ) h (l-head) i = F F N (l-head) (r i ) h (l-dep) i = F F N (l-dep) (r i ) s (edge) i,j = BiAf f (edge) 1 h (dep) i , h (head) j s (label) i,j = BiAf f (label) k h (l-dep) i , h (l-head) j s (top) i = F F N (top) (r i ) (1) where k is the number of node labels, and f is the activation function used in the feed-forward layer F F N .  4  In contrast to the setting of  (Dozat and Manning, 2018) , the top score s (top) i is newly introduced in our model, where we exploit a simple feed-forward layer for predicting top nodes instead of using an attention method. Using the score functions of Eq. (  1 ), the prediction results for arcs, labels, and top nodes are formulated as follows: y (edge) i,j = I s edge i,j ? 0 y (label) i,j = argmax s (label) i,j y (top) i = I s (top) i ? 0 (2) where I(expr) is an indicator function which gives 1 if expr is true and 0 otherwise. 

 Multi-level Biaffine attention We also investigated a multi-level biaffine attention, whose information flow is described in  , respectively. more abstract high-level representation. In the task of semantic graph parsing, predicting an arc and a label may be resolved not just by single-level representation but by the combination of various levels of representations; For example, predicting an arc between two deep semantic subgraphs (with high depths) may require more abstract representations for those graphs than the case of predicting an arc between two shallow semantic subgraphs (with low depths). The multi-level biaffine attention is based on the fusion of all the role-dependent representations across levels.  5  This type of multi-level attention is different from deep biaffine attention of  (Dozat and Manning, 2018) , which uses only single roledependent hidden representation at the final level. To formulate the multi-level biaffine attention, we first apply deep BiLSTM encoder of L-levels to a list of word embeddings x 1 , ? ? ? , x n as follows. r i,0 = x i r i,l = BiLST M i (r 1,l?1 ? ? ? r n,l?1 ) where r i,l is the hidden representation of the BiL-STM at the l-th layer. The role-dependent representation for each l-th layer is formulated as follows: h (head) i,l = F F N (head) (r i,l ) h (dep) i,l = F F N (dep) (r i,l ) 5 A pair of syntactic roles in role-dependent representations are considered -head-dependent roles (or predicateargument roles). To aggregate all the role-dependent representations, we use the fusion function, denoted as o = f usion(x, y), as defined in  (Hu et al., 2018) : x = gleu (W r [x; y; x y; x ? y]) g = ? (W g [x; y; x y; x ? y]) o = g x + (1 ? g) x where is element-wise multiplication. For notational simplicity, we further define sf u(x, y, z), the fusion function that takes three arguments, as follows: sf u (x, y, z) = f usion (f usion (x, y) , z) Applying the sf u function results in the compositional role-dependent representations z  z (head) i = sf u (head) h (head) i,1 , h (head) i,2 , h (head) i,3 z (dep) i = sf u (dep) h (dep) i,1 , h (dep) i,2 , h (dep) i,3 s (edge ) i,j = BiAf f (edge ) 1 z (dep) i , z (head) j (3) Similar to the arc scores in Eq. (3), we straightforwardly define multi-level terms related to label scores such as h (l-dep) i,k , h (l-head) i,k , z (l-head) i , and z (l-dep) i . 

 Property prediction based on BiLSTM To predict frame information, which is one of the node properties in DM and PSD, we use a simple BiLSTM architecture with a single output layer that generates a node property for each word.  6  Different from the biaffine attention model, the property predictor does not use BERT but a simple word representation that consists of the pretrained GloVe and the POS tag embedding as follows: x (prop) i = e glove i ; e P OS i For encoding a sentence, another BiLSTM is then applied to the sequence of word representations, as follows: r (prop) i = BiLST M (prop) i (x 1 ? ? ? x n ) The output layer uses the following simple affine transformation: s (prop) i = F F N (prop) r (prop) i (4) The loss function uses the cross entropy, which is formulated given a single training sentence as follows: L (prop) = i log sof tmax g(i) s (prop) i (5) where g(i) is the gold property value of the i-th word and sof tmax k is the function of k-th element of softmax values. 7 3 Training 

 Preprocessing We use word tokens and their POS tags in the companion dataset provided by MRP 2019. To perform UCCA parsing using biaffine attention, conversion between UCCA and bilexical formats is required. For the conversion, we use the semstr tool, which is based on the head rules defined in  (Hershcovich et al., 2017) . 

 Multi-task learning on a single framework In each semantic graph framework, the biaffine attention models consist of three subtasks -edge detection, edge labeling, and top node prediction. We jointly train the neural components of all the subtasks for each framework in the multi-task learning setting using the following combined loss function: L = ? 1 L (edge) + ? 2 L (label) + ? 3 L (top) (6) where L (edge) , L  (label)  , and L (top) are the loss functions for edge detection, edge labeling, and top node prediction, respectively, and ? i is the weight for each loss function. However, the property predictor of Section 2.4 is not jointly trained on a single framework because its neural components can be shared in any component in the biaffine attention models.  

 Multi-task learning across frameworks To enable multi-task learning across frameworks, we share the BERT-BiLSTM encoder as a common neural component across three frameworks and use framework-specific models for the biaffine attention decoder. Our approach to multi-task learning is similar to that of SHARED1 of  (Peng et al., 2017) . In multi-task learning, we alternate training examples for each framework using the frameworkspecific loss function of Eq. (  6 ) such that, over each epoch, all the training examples across the three frameworks are fairly fed without bias to a specific framework. 

 Hyperparameters We used Adam optimizer  (Kingma and Ba, 2015)  to train our biaffine attention models. In this section, we present the preliminary experimental results, which compare variants of our models. To perform the preliminary experiment, we randomly split the MRP 2019 dataset into training and development sets. Table  2  shows the statistics of training and development sets for the three frameworks. The evaluation measures are unlabeled dependency F1 scores (UF), labeled dependency F1 scores (LF), and top node prediction accuracy (Top). We report the evaluation metrics for the development sets. 

 Experimental results We evaluated the following four biaffine attention methods: 1. Biaffine: This model is the baseline biaffine attention model based on the BiLSTM sentence encoder without using BERT. 2. BERT+Biaffine: This model uses the BERT-BiLSTM encoder of Section 2.1 and the biaffine attention model of Section 2.2. 3. BERT+Multi-level Biaffine: This model uses BERT-BiLSTM encoder of Section 2.1 and uses the multi-level attention method of Section 2.3. 

 BERT+Biaffine+MTL: This model is the same as BERT+Biaffine but uses the multitask learning across frameworks described in Section 3.3. Table  3  shows the UF, LF, and Top on the three semantic graph frameworks, comparing the four variants of biaffine attention models. BERT+Biaffine performs better than Biaffine, in particular, obtaining the increases of about 5% for UF and LF on the UCCA framework. However, BERT+Multi-level Biaffine does not achieve any further improvements with respect to Biaffine, often yielding weak performances similar to that of the BERT-Biaffine model on the PSD and UCCA frameworks. BERT+Biaffine+MTL only achieves small improvements on UCCA framework whereas no improvements on DM and PSD frameworks can be observed. A statistically insignificant improvement for multi-task learning in BERT+Biaffine+MTL was similarly reported in the results of SHARED1 in  (Peng et al., 2017) . These results imply that instead of naively using the shared encoder only, other advanced multi-task learning approaches such as placing task-specific encoding, as detailed in  (Peng et al., 2017) , need to be considered. 

 Official Results Given the preliminary results, we chose the basic biaffine model "BERT+Biaffine" of Table  3  for the final submission to MRP 2019. The official results using BERT+Biaffine are summarized in Tables  4 and 5 , which compare the results of ERG  (Oepen and Flickinger, 2019)  and TUPA  (Hershcovich and Arviv, 2019)  which were provided by the task organizer. Table  4  shows the performances of the MRP metrics on the three frameworks, whereas Table  5  presents the performances of task-specific metrics using the SDM metrics  and UCCA metric . The SDM metrics use the unlabeled dependency precision/recall/F1 (UP/UR/UF), the labeled dependency precision/recall/F1 (LP/LR/LF), and the unlabeled/labeled exact matches (UM/LM). The UCCA metrics use the unlabeled and labeled arc precision/recall/F1 for primary, remote and all types of arcs.  8  Overall, our system shows better performances over the baseline TUPA's system, except for the results of UCCA metrics. Comparing to ERG which is the top-performing system in MRP metric on DM, our biaffine system shows slightly improved performance over ERG in terms of UF of the SDP metric. Comparing to the published MRP metrics of the best system (i.e. MRP all metric), the performances of our system are about 1.  

 Summary and Conclusion In this paper, we presented the Jeonbuk National University's system based on unified biaffine attention models for DM, PSD, and UCCA frameworks for the MRP 2019 task. We investigated the extensions of the original biaffine models using multi-level biaffine attention and multi-task learning. The preliminary experiment results show that the use of multi-level models and multi-task learning had no effect on MRP performances under our current settings. The statistically insignificant results of multi-task learning imply that there may be some necessary conditions beyond the default setting to meet before multi-task learning with parameter sharing is effective. In this direction, we plan to explore why multi-task learning is not effective in our current experiment, try to postulate reasonable hypothesis that will help clarifying the effect of multi-task learning, and further examine other advanced multi-task learning including the approaches of  (Peng et al., 2017) . In addition, we would like to examine alternative fusion functions for multi-level affine attention.   The official results of task-specific metrics on the three frameworks, comparing ERG  (Oepen and Flickinger, 2019) , TUPA  (Hershcovich and Arviv, 2019) , and our system (BERT+Biaffine). 1 

 Figure 1 : 1 Figure 1: Biaffine attention for bilexical semantic dependency parsing based on word representation using BERT, Glove and POS embeddings. 

 , as shown in Figure 2. An input sentence is segmented into word- 

 Figure 2 : 2 Figure 2: BERT Word embedding using Bi-LSTM. 

 Figure 3. Motivated by (Huang et al., 2018), we assume that multi-layer encoders gradually transform from a low-level word representation into a 

 Figure 3 : 3 Figure 3: The neural architecture of multi-level biaffine attention. The hidden representations at three levels h (dep) i,k and h (head) j,k are composed to the final hidden 

 i at the i-th position. The multi-level biaffine attention is then defined on z 

 Table 1 : 1 Hyper-parameter settings GloVe source 840B dim 300 BERT layer source BERT-Base-cased dim 784 Word embedding layer: BiLSTM hidden size 384 num layers 1 Sentence encoder: BiLSTM hidden size 600 num layers 3 (Multi-level) Biaffine decoder hidden size 600 Property predictor BiLSTM hidden size 600 BiLSTM num layers 3 output vocab size(DM) 474 output vocab size(PSD) 5474 Adam optimizer learning rate 0.001 weight decay rate 3e-9 Adam ?1 0.0 Adam ?2 0.95 BERT Adam optimizer learning rate 2e-5 weight decay rate 0.01 Adam ?1 0.9 Adam ?2 0.999 Loss for multi-task learning of Eq. (6) ?1 0.025 ?2 0.975 ?3 1.0 batch size 16 

 Table 1 1 summarizes the hyper-parameters used for train- ing these models 

 Table 2 : 2 Statistics of dataset used in the preliminary experiment 4 Unofficial Results: Preliminary Experiment 

 Table 3 : 3 Unofficial results of Top, UF, and LF metrics on the three frameworks (DM, PSD, and UCCA), comparing variants of biaffine attention models. 5 percentage 

 .91 0.9142 0.77 0.80 0.7833 0.33 0.28 0.3026 0.19 0.11 0.1405 0.53 0.49 0.5069 lpps 0.91 0.91 0.9100 0.90 0.92 0.9126 0.47 0.42 0.4411 0.13 0.07 0.0882 0.66 0.62 0.6365 (c) The official results of MRP metrics on the UCCA framework method P tops R F P labels R F properties P R F P anchors R F P edges R F P all R F ERG all 0.92 0.92 0.92 0.99 0.99 0.99 0.96 0.96 0.96 0.99 0.99 0.99 0.91 0.91 0.91 0.96 0.96 0.9608 lpps 0.95 0.95 0.95 0.99 0.99 0.99 0.98 0.98 0.98 0.99 1.00 0.99 0.93 0.93 0.93 0.97 0.97 0.9731 TUPA all 0.53 0.51 0.52 0.40 0.75 0.52 0.22 0.66 0.33 0.85 0.83 0.84 0.24 0.54 0.33 0.31 0.69 0.4270 lpps 0.74 0.67 0.71 0.35 0.73 0.48 0.19 0.64 0.29 0.85 0.84 0.85 0.21 0.56 0.31 0.28 0.68 0.3946 BERT+Biaffine all 0.92 0.92 0.92 0.91 0.90 0.90 0.91 0.95 0.94 0.95 0.99 0.98 0.99 0.92 0.91 0.94 0.94 0.9401 lpps 0.96 0.96 0.96 0.88 0.88 0.88 0.91 0.92 0.91 0.98 0.98 0.98 0.93 0.92 0.92 0.92 0.92 0.9240 (a) The official results of MRP metrics on the DM framework method P tops R F P labels R F properties P R F P anchors R F P edges R F P all R F TUPA all 0.58 0.46 0.51 0.56 0.77 0.65 0.34 0.57 0.42 0.82 0.80 0.80 0.27 0.39 0.32 0.45 0.63 0.5265 lpps 0.62 0.53 0.57 0.58 0.77 0.66 0.31 0.60 0.41 0.82 0.81 0.81 0.30 0.42 0.35 0.47 0.65 0.5453 BERT+Biaffine all 0.96 0.96 0.96 0.86 0.85 0.86 0.88 0.88 0.88 0.99 0.98 0.99 0.79 0.78 0.78 0.88 0.88 0.88 lpps 0.96 0.96 0.96 0.77 0.77 0.77 0.78 0.95 0.86 0.98 0.98 0.98 0.79 0.79 0.79 0.84 0.88 0.8568 (b) The official results of MRP metrics on the PSD framework method P tops R F P anchors R F P edges R F P attributes R F P all R F TUPA all 0.87 0.83 0.8492 0.90 0.52 0.6574 0.08 0.29 0.1299 0.10 0.08 0.0907 0.17 0.38 0.2365 lpps 0.90 0.88 0.8889 0.93 0.67 0.7776 0.19 0.42 0.2645 0.28 0.14 0.1832 0.34 0.52 0.4104 BERT+Biaffine all 0.91 0 

 Table 4 : 4 The official results of MRP metrics on the three frameworks (DM, PSD, and UCCA), comparing ERG (Oepen and Flickinger, 2019) , TUPA (Hershcovich and Arviv, 2019) , and our system (BERT+Biaffine). method LP LR labeled LF LM unlabeled UP UR UF UM ERG all 0.91 0.91 0.9121 0.5144 0.92 0.92 0.9204 0.5374 lpps 0.93 0.93 0.9295 0.6900 0.93 0.94 0.9348 0.7200 TUPA all 0.51 0.62 0.5623 0.0723 0.63 0.66 0.6430 0.0848 lpps 0.50 0.63 0.5571 0.1400 0.62 0.67 0.6468 0.1700 BERT+Biaffine all 0.92 0.90 0.9119 0.3998 0.93 0.92 0.9233 0.4329 lpps 0.93 0.92 0.9265 0.5700 0.95 0.94 0.9413 0.6100 (a) The official results of SDP metrics on the DM framework method LP LR labeled LF LM unlabeled UP UR UF UM TUPA all 0.47 0.53 0.5012 0.0863 0.65 0.67 0.6599 0.2200 lpps 0.52 0.59 0.5533 0.1500 0.67 0.71 0.6876 0.2700 BERT+Biaffine all 0.80 0.80 0.7998 0.1920 0.92 0.91 0.9164 0.4519 lpps 0.82 0.81 0.8147 0.2800 0.93 0.93 0.9272 0.5500 (b) The official results of SDP metrics on the PSD framework labeled unlabeled method primary remote all primary remote all P R F P R F P R F P R F P R F P R F TUPA all 0.30 0.19 0.23 0.08 0.06 0.07 0.28 0.19 0.22 0.37 0.23 0.28 0.09 0.06 0.07 0.35 0.22 0.27 lpps 0.33 0.26 0.29 0.21 0.10 0.14 0.32 0.25 0.28 0.38 0.31 0.34 0.23 0.10 0.14 0.38 0.30 0.33 BERT+Biaffine all 0.19 0.17 0.18 0.13 0.08 0.10 0.19 0.17 0.18 0.23 0.20 0.21 0.13 0.08 0.10 0.22 0.20 0.21 lpps 0.35 0.32 0.34 0.04 0.02 0.03 0.34 0.31 0.33 0.41 0.39 0.40 0.04 0.02 0.03 0.40 0.37 0.38 (c) The official results of UCCA metrics on the UCCA framework 

 Table 5 : 5 

			 This aggregation is similar to the BiLSTM-based composition in (Ballesteros et al., 2015; Na et al., 2018)  which uses characters as subtokens, whereas our aggregation uses word pieces as subtokens. 

			 In our submission, we used the identity function for f . 

			 Here, words (or tokens) correspond to nodes in a semantic graph. 

			 We allow a NULL value to be a gold property value. Given this setting, the values of g(i) are mostly NULL in the frame property of PSD. 

			 Our system ranked fifth for framework-specific LF on DM and PSD, ranked eighth on UCCA, first for frameworkspecific UF using the 100-sentence LPPS sub-set, and second for LF on the PSD framework.
