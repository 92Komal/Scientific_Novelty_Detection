title
Arc-swift: A Novel Transition System for Dependency Parsing

abstract
Transition-based dependency parsers often need sequences of local shift and reduce operations to produce certain attachments. Correct individual decisions hence require global information about the sentence context and mistakes cause error propagation. This paper proposes a novel transition system, arc-swift, that enables direct attachments between tokens farther apart with a single transition. This allows the parser to leverage lexical information more directly in transition decisions. Hence, arc-swift can achieve significantly better performance with a very small beam size. Our parsers reduce error by 3.7-7.6% relative to those using existing transition systems on the Penn Treebank dependency parsing task and English Universal Dependencies.

Introduction Dependency parsing is a longstanding natural language processing task, with its outputs crucial to various downstream tasks including relation extraction  (Schmitz et al., 2012; Angeli et al., 2015) , language modeling  (Gubbins and Vlachos, 2013) , and natural logic inference  (Bowman et al., 2016) . Attractive for their linear time complexity and amenability to conventional classification methods, transition-based dependency parsers have sparked much research interest recently. A transition-based parser makes sequential predictions of transitions between states under the restrictions of a transition system  (Nivre, 2003) . Transition-based parsers have been shown to excel at parsing shorter-range dependency structures, as well as languages where non-projective parses are less pervasive  (McDonald and Nivre, 2007) . However, the transition systems employed in state-of-the-art dependency parsers usually define very local transitions. At each step, only one or two words are affected, with very local attachments made. As a result, distant attachments require long and not immediately obvious transition sequences (e.g., ate?chopsticks in Figure  1 , which requires two transitions). This is further aggravated by the usually local lexical information leveraged to make transition predictions  (Chen and Manning, 2014; Andor et al., 2016) . In this paper, we introduce a novel transition system, arc-swift, which defines non-local transitions that directly induce attachments of distance up to n (n = the number of tokens in the sentence). Such an approach is connected to graph-based dependency parsing, in that it leverages pairwise scores between tokens in making parsing decisions  (McDonald et al., 2005) . We make two main contributions in this paper. Firstly, we introduce a novel transition system for dependency parsing, which alleviates the difficulty of distant attachments in previous systems by allowing direct attachments anywhere in the stack. Secondly, we compare parsers by the number of mistakes they make in common linguistic con- arc-standard arc-hybrid Shift (?, i|?, A) ? (?|i, ?, A) LArc (?|i|j, ?, A) ? (?|j, ?, A ? {(j ? i)}) RArc (?|i|j, ?, A) ? (?|i, ?, A ? {(i ? j)}) Shift (?, i|?, A) ? (?|i, ?, A) LArc (?|i, j|?, A) ? (?, j|?, A ? {(j ? i)}) RArc (?|i|j, ?, A) ? (?|i, ?, A ? {(i ? j)}) arc-eager arc-swift Shift (?, i|?, A) ? (?|i, ?, A) LArc (?|i, j|?, A) ? (?, j|?, A ? {(j ? i)}) RArc (?|i, j|?, A) ? (?|i|j, ?, A ? {(i ? j)}) Reduce (?|i, ?, A) ? (?, ?, A) Shift (?, i|?, A) ? (?|i, ?, A) LArc[k] (?|i k | . . . |i 1 , j|?, A) ? (?, j|?, A ? {(j ? i k )}) RArc[k] (?|i k | . . . |i 1 , j|?, A) ? (?|i k |j, ?, A ? {(i k ? j)}) Figure  2 : Transitions defined by different transition systems. structions. We show that arc-swift parsers reduce errors in attaching prepositional phrases and conjunctions compared to parsers using existing transition systems. 

 Transition-based Dependency Parsing Transition-based dependency parsing is performed by predicting transitions between states (see Figure  1  for an example). Parser states are usually written as (?|i, j|?, A), where ?|i denotes the stack with token i on the top, j|? denotes the buffer with token j at its leftmost, and A the set of dependency arcs. Given a state, the goal of a dependency parser is to predict a transition to a new state that would lead to the correct parse. A transition system defines a set of transitions that are sound and complete for parsers, that is, every transition sequence would derive a well-formed parse tree, and every possible parse tree can also be derived from some transition sequence. 1 Arc-standard  (Nivre, 2004 ) is one of the first transition systems proposed for dependency parsing. It defines three transitions: shift, left arc (LArc), and right arc (RArc) (see Figure  2  for definitions, same for the following transition systems), where all arc-inducing transitions operate on the stack. This system builds the parse bottom-up, i.e., a constituent is only attached to its head after it has received all of its dependents. A potential drawback is that during parsing, it is difficult to predict if a constituent has consumed all of its right dependents. Arc-eager  (Nivre, 2003)  remedies this drawback by defining arc-inducing transitions that operate between the stack and the buffer. As a result, a constituent no longer needs to be complete  1  We only focus on projective parses for the scope of this paper. before it can be attached to its head to the left, as a right arc doesn't prevent the attached dependent from taking further dependents of its own. 2  Kuhlmann et al. (2011)  propose a hybrid system derived from a tabular parsing scheme, which they have shown both arc-standard and arc-eager can be derived from. Arc-hybrid combines LArc from arc-eager and RArc from arc-standard to build dependencies bottom-up. 

 Non-local Transitions with arc-swift The traditional transition systems discussed in Section 2 only allow very local transitions affecting one or two words, which makes long-distance dependencies difficult to predict. To illustrate the limitation of local transitions, consider parsing the following sentences: I ate fish with ketchup. I ate fish with chopsticks. The two sentences have almost identical structures, with the notable difference that the prepositional phrase is complementing the direct object in the first case, and the main verb in the second. For arc-standard and arc-hybrid, the parser would have to decide between Shift and RArc when the parser state is as shown in Figure  3a , where stands for either "ketchup" or "chopsticks". 3 Similarly, an arc-eager parser would deal with the state shown in Figure  3b . Making the correct transition requires information about context words "ate" and "fish", as well as " ". In these states, parsers would need to incorporate context about "ate", "fish", and " " to make the correct local transition. Parsers employing traditional transition systems would usually incorporate more features about the context in the transition decision, or employ beam search during parsing  (Chen and Manning, 2014; Andor et al., 2016) . In contrast, inspired by graph-based parsers, we propose arc-swift, which defines non-local transitions as shown in Figure  2 . This allows direct comparison of different attachment points, and provides a direct solution to parsing the two example sentences. When the arc-swift parser encounters a state identical to Figure  3b , it could directly compare transitions RArc[1] and RArc[2] instead of evaluating between local transitions. This results in a direct attachment much like that in a graph-based parser, informed by lexical information about affinity of the pairs of words. Arc-swift also bears much resemblance to arceager. In fact, an LArc[k] transition can be viewed as k ? 1 Reduce operations followed by one LArc in arc-eager, and similarly for RArc  [k] . Reduce is no longer needed in arc-swift as it becomes part of LArc[k] and RArc[k], removing the ambiguity in derived transitions in arc-eager. arc-swift is also equivalent to arc-eager in terms of soundness and completeness.  4  A caveat is that the worst-case time complexity of arc-swift is O(n 2 ) instead of O(n), which existing transition-based parsers enjoy. However, in practice the runtime is nearly 4 This is easy to show because in arc-eager, all Reduce transitions can be viewed as preparing for a later LArc or RArc transition. We also note that similar to arc-eager transitions, arc-swift transitions must also satisfy certain pre-conditions. Specifically, an RArc[k] transition requires that the top k ? 1 elements in the stack are already attached; LArc  [k]  additionally requires that the k-th element is unattached, resulting in no more than one feasible LArc candidate for any parser state. linear, thanks to the usually small number of reducible tokens in the stack. Our model is very similar to that of (Kiperwasser and , where features are extracted from tokens with bidirectional LSTMs, and concatenated for classification. For the three traditional transition systems, features of the top 3 tokens on the stack and the leftmost token in the buffer are concatenated as classifier input. For arc-swift, features of the head and dependent tokens for each arc-inducing transition are concatenated to compute scores for classification, and features of the leftmost buffer token is used for Shift. For other details we defer to Appendix A. The full specification of the model can also be found in our released code online at https://github. com/qipeng/arc-swift. 

 Experiments 

 Results We use static oracles for all transition systems, and for arc-eager we implement oracles that always Shift/Reduce when ambiguity is present (arceager-S/R). We evaluate our parsers with greedy parsing (i.e., beam size 1). The results are shown in Table  1 .  5  Note that K&G 2016 is trained with a dynamic oracle  (Goldberg and Nivre, 2012) , Andor 2016 with a CRF-like loss, and both Andor 2016 and Weiss 2015 employed beam search (with sizes 32 and 8, respectively). For each pair of the systems we implemented, we studied the statistical significance of their difference by performing a paired test with 10,000 bootstrap samples on PTB-SD. Each grid shows adjusted test result for UAS and LAS, respectively, showing whether the system on the row is significantly better than that on the column. "***" stands for p < 0.001, "**" p < 0.01, "*" p < 0.05, and "-" p ? 0.05. that with almost the same implementation, arcswift parsers significantly outperform those using traditional transition systems. We also analyzed the performance of parsers on attachments of different distances. As shown in Figure  4 , arc-swift is equally accurate as existing systems for short dependencies, but is more robust for longer ones. While arc-swift introduces direct long-distance transitions, it also shortens the overall sequence necessary to induce the same parse. A parser could potentially benefit from both factors: direct attachments could make an easier classification task, and shorter sequences limit the effect of error propagation. However, since the two effects are correlated in a transition system, precise attribution of the gain is out of the scope of this paper. Computational efficiency. We study the computational efficiency of the arc-swift parser by 6 https://github.com/tensorflow/models/ blob/master/syntaxnet/g3doc/universal.md comparing it to an arc-eager parser. On the PTB-SD development set, the average transition sequence length per sentence of arc-swift is 77.5% of that of arc-eager. At each step of parsing, arc-swift needs to evaluate only about 1.24 times the number of transition candidates as arc-eager, which results in very similar runtime. In contrast, beam search with beam size 2 for arc-eager requires evaluating 4 times the number of transition candidates compared to greedy parsing, which results in a UAS 0.14% worse and LAS 0.22% worse for arc-eager compared to greedily decoded arcswift. 

 Linguistic Analysis We automatically extracted all labelled attachment errors by error type (incorrect attachment or relation), and categorized a few top parser errors by hand into linguistic constructions. Results on PTB-SD are shown in Table  3 .  7  We note that the arc-swift parser improves accuracy on prepositional phrase (PP) and conjunction attachments, while it remains comparable to other parsers on other common errors. Analysis on EN-UD shows a similar trend. As shown in the table, there are still many parser errors unaccounted for in our analysis. We leave this to future work.  

 Related Work Previous work has also explored augmenting transition systems to facilitate longer-range attachments.  Attardi (2006)  extended the arcstandard system for non-projective parsing, with arc-inducing transitions that are very similar to those in arc-swift. A notable difference is that their transitions retain tokens between the head and dependent. Fern?ndez-Gonz?lez and G?mez-Rodr?guez (  2012 ) augmented the arc-eager system with transitions that operate on the buffer, which shorten the transition sequence by reducing the number of Shift transitions needed. However, limited by the sparse feature-based classifiers used, both of these parsers just mentioned only allow direct attachments of distance up to 3 and 2, respectively. More recently,  Sartorio et al. (2013)  extended arc-standard with transitions that directly attach to left and right "spines" of the top two nodes in the stack. While this work shares very similar motivations as arc-swift, it requires additional data structures to keep track of the left and right spines of nodes. This transition system also introduces spurious ambiguity where multiple transition sequences could lead to the same correct parse, which necessitates easy-first training to achieve a more noticeable improvement over arcstandard. In contrast, arc-swift can be easily implemented given the parser state alone, and does not give rise to spurious ambiguity. For a comprehensive study of transition systems for dependency parsing, we refer the reader to  (Bohnet et al., 2016) , which proposed a generalized framework that could derive all of the traditional transition systems we described by configuring the size of the active token set and the maximum arc length, among other control parameters. However, this framework does not cover arc-swift in its original form, as the authors limit each of their transitions to reduce at most one token from the active token set (the buffer). On the other hand, the framework presented in  (G?mez-Rodr?guez and Nivre, 2013)  does not explicitly make this constraint, and therefore generalizes to arc-swift. However, we note that arc-swift still falls out of the scope of existing discussions in that work, by introducing multiple Reduces in a single transition. 

 Conclusion In this paper, we introduced arc-swift, a novel transition system for dependency parsing. We also performed linguistic analyses on parser outputs and showed arc-swift parsers reduce errors in conjunction and adverbial attachments compared to parsers using traditional transition systems.  
