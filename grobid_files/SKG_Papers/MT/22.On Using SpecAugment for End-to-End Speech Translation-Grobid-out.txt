title
On Using SpecAugment for End-to-End Speech Translation

abstract
This work investigates a simple data augmentation technique, SpecAugment, for end-to-end speech translation. SpecAugment is a low-cost implementation method applied directly to the audio input features and it consists of masking blocks of frequency channels, and/or time steps. We apply SpecAugment on end-to-end speech translation tasks and achieve up to +2.2% BLEU on LibriSpeech Audiobooks En?Fr and +1.2% on IWSLT TED-talks En?De by alleviating overfitting to some extent. We also examine the effectiveness of the method in a variety of data scenarios and show that the method also leads to significant improvements in various data conditions irrespective of the amount of training data.

Introduction Traditional speech-to-text translation (ST) systems have been build in a cascaded fashion comprised of an automatic speech recognition (ASR) model trained on paired speechtranscribed data and a machine translation (MT) model trained on bilingual text data. Recent advancements in both ASR  [1] [2] [3] [4] [5] [6]  and MT  [7] [8] [9] [10] [11]  have inspired the end-to-end direct ST models which can be trained using a translation speech corpus  [12, 13] . Some appealing advantages of the direct models are:  (1)  no error accumulation from the recognizer, (2) faster decoding throughput and (3) less computational power in total by training all parameters jointly. In spite of these properties, training such end-to-end ST models requires a moderate amount of paired translated speech-totext data which is not easy to acquire. Therefore these models tend to overfit easily. In the absence of an adequate volume of training data, one remedy is generating synthetic data like back-translation (BT)  [14]  as the most common data augmentation method to leverage monolingual data. The idea is to use a pretrained model to convert weakly supervised data into speechto-translation pairs for ST training  [15] . One way is to use a pre-trained source-to-target MT model to translate ASR transcription into the target language. Another method is the use of a pre-trained text-to-speech (TTS) model to generate speech data from a monolingual text. However, these methods require some effort to train an additional model, as well as computational power to generate a moderate amount of (noisy) synthetic data, which in some cases can be too ex-pensive to be obtained. Another method is data augmentation by which new synthetic training samples are generated by corrupting the initial audio data and conserving the same label as the original training sample. Audio-level speech augmentation can be done in different ways such as noise injection (adding random noise), shifting time (transmitting time series forward/backward with a few seconds), speed perturbation (expanding time series by a speed rate) and changing the frequency pitch randomly. Besides increasing the quantity of training data, data augmentation often make the model invariant to the applied noise and enhance its ability to generalize. Inspired by the success of augmentation methods in ASR  [16, 17] , as a remedy to avoid overfitting while using lowresource translated speech data, we study the use of spectrogram augmentation (SpecAugment) for direct ST model. SpecAugment  [16]  is a simple and low-implementation cost approach. Unlike traditional speech augmentation methods that directly manipulate the input signal, SpecAugment is applied on the audio features, which are usually mel spectrogram of the input signal. We utilize two kinds of deformations of the spectrogram which are time and frequency masking, where we mask a block of consecutive time steps and/or mel frequency channels. Our main motivation of using SpecAugment is the potential avoidance of overfitting, better generalization beyond low-resource training data and improving robustness of the end-to-end models. In this paper, we aim to shed light on the following questions. First, does SpecAugment strategy help the direct ST model? Second, what is the effect of the approach concerning the different amount of training data? Our first contribution is an extensive empirical investigation of SpecAugment on top-performing ST systems to validate or disprove the above conjectures. Our aim is not to compare with other data augmentation strategies, but the effectiveness of the SpecAugment as a stand-alone method. We hope that this method might overcome the data efficiency issue and therefore, as our second contribution, we explore the effect of that on a various amount of training data. Our experimental results on LibriSpeech Audiobooks En?Fr and IWSLT TED-talks En?De show that the method not only greatly outperforms direct ST model up to +1.7% BLEU on average, but also diminishes the overfitting problem. We also show that our improvements are valid in different data scenarios irrespective of the amount of training data. 

 Spectrogram Augmentation In spectrogram augmentation (SpecAugment)  [16] , we randomly apply masking in consecutive frames in the time axis as well as consecutive dimensions in the feature axis. Since the author stated that the time warping is the most expensive and the least influential, we do not explore it here. 

 Time Masking Time masking is masking of ? successive time steps [t,t + ?), where we set (x t , . . . , x t+? ) := 0, where ? is the masking window which is selected from a uniform distribution from 0 to the maximum time mask parameter R. (x 1 , . . . , x T ) are the input audio features, and T is the length of the input signal. The time position t is picked from another uniform distribution over [0, T ) 1 such that we never exceed the maximum sequence length T (i.e. if t + ? > T , we set it to T ). We apply the time masking procedure for m R ? N 0 times. We also ensure that if m R > 1, the same time position t is not selected more than once (i.e. without replacement) 2 . 

 Frequency Masking Frequency masking can be also applied such that ? consecutive frequency channels [ f , f + ? ) are masked, where ? is chosen from a uniform distribution from 0 to the frequency mask parameter F, and f is chosen from [0, ?)  3  . ? is the input feature dimension, e.g. the number of mel frequency channels. Similar to time masking, we do not allow for already selected f and check if f + ? > ?, we set it to ?. Figure  1  shows examples of the individual augmentations applied to a single input. Multiple frequency and time masks might overlap. m F ? N 0 refers to the number of times we apply the frequency masks. We note that we standardize the  1  We choose time position differently from the original paper where they select t in the interval of [0, T ? ?)  [16] .  2  It is not clear whether the original paper allows replacement or not.  3  Again we note the difference between our implementation and the original paper where the selection interval is [0, ? ? ? )  [16] . log mel features to zero mean and variance of one. Therefore, masking to zero is equivalent to setting it to the mean value. In this work, we mainly investigate a series of combinations to find a reliable recipe for direct ST model. We only apply the SpecAugment during training. 

 Network In ST, given an input observation (audio feature vectors) of variable length T , x T 1 , a sequence of discrete label of unknown length J (source sequence/transcribed words), f J 1 and a sequence of target words of unknown length I, e I 1 , the posterior probability of a target sequence is defined as: p(e I 1 |x T 1 ) = I ? i=1 p(e i |e i?1 1 , x T 1 ) (1) where usually T > I, J. This posterior can be modeled directly in an end-to-end fashion. Here, we only address the direct end-to-end architecture that is used in our experiments. The direct model is based on the attention sequence-tosequence model  [8]  composed of long short-term memories (LSTMs)  [18]  similar to  [19] . We only focus on LSTMbased models and leave the transformer architecture as our future study  [10, 20, 21] . An abstract overview of the network and a summary of the model are shown in Figure  2  and written in Equation 2 respectively. A bidirectional LSTM (BLSTM) scans the input sequence once from left to right and once from right to left. To handle the long speech utterances, we apply max-pooling in the time-dimension at multiple steps inside the speech encoder. For the input sequence x T 1 , we end up with the encoder states h T 1 , where T = T /red with the time reduction factor red. Then, the decoder LSTM generates an output sequence conditioned on the encoder representations. While computing e i at each time step, an additive attention function is used to produce normalized attention weights ? i,t . The context vector c i is then computed as a weighted sum of encoder representations. A transformation followed by a softmax operation predicts e i . Finally, the decoder state is updated to s i . Here, L e and L d are the number of encoder and decoder layers respectively. ? is the concatenation operator of functions. h T 1 = (BLSTM L e ? ? ? ? ? max-pool 1 ? BLSTM 1 )(x T 1 ) ? i,t = softmax t linear(tanh(linear(s i?1 , h t ))) c i = T ? t=1 ? i,t h t p(e i |e i?1 1 , x T 1 ) = softmax e linear(e i?1 , s i?1 , c i ) s i = LSTM L d ? ? ? ? ? LSTM 1 (e i , s i?1 , c i ) (2) 4. Experiments LibriSpeech En?Fr: As suggested by  [23] , to double the training data size, we concatenate the original translation and the Google Translate reference which have been provided in the dataset package. Hence, we end up to 200h of clean speech corresponding to 94.5k segments for the ST task. We apply 40-dimensional Gammatone features  [26]  using the RASR feature extractor  [27] . For MT training, we utilize no additional data and only use the source-target data from the ST task, i.e. 94.5k. For ASR training, we take both the ASR and ST data resulting in 330h. The dev and test sets contain 2h and 4h of speech, 1071 and 2048 segments respectively. Here, the dev set is used as our cross-validation set as well as checkpoint selection. IWSLT En?De: Similar to  [19, 28] , we extract 80dimensional Mel-frequency cepstral coefficients (MFCC) features. We automatically recompute the provided audio-tosource-sentence alignments to reduce the problem of speech segments without a translation. We use the TED-LIUM corpus including 207h and the IWSLT speech translation TED corpus with 272h of speech data for ASR training. For MT training, we use the TED, and the OpenSubtitles2018 corpora, as well as the data provided by the WMT 2018 evaluation (Europarl, ParaCrawl, CommonCrawl, News Commentary, and Rapid), a total of 65M lines of parallel sentences. We filter these data based on several heuristics resulting in 32M samples. We randomly select a part of our segments as our cross-validation set and choose dev2010 and test2015 as our dev and test sets with 888 and 1080 segments respec- 

 Models In our experiments, we build ASR, MT, and ST models all based on the network described in Section 3. The ASR and MT models are used for building the cascade pipeline as well as pre-training the components of the ST model. Thus, the ASR and ST models use the same speech encoder architecture, whilst the MT and ST models use the same text decoder topology, as illustrated in Figure  2 . For both tasks, we apply separate byte pair encoding (BPE)  [33]  with 20k symbols on both side of the MT data, whereas 10k merge operations on the ASR transcriptions. ASR model: All tokens are mapped into a 512-dimensional embedding space. The encoder is composed of 6 stacked BLSTM layers with 1024 nodes. The decoder is a 1-layer unidirectional LSTM of size 1024. A single head additive attention with alignment feedback  [34, 35]  is used as our attention component. Similar to  [4, 19] , we apply layer-wise pre-training for the encoder, where we start with two encoder layers and a single max-pool in between BLSTM layers. We apply 2 max-pooling layers with pool-size of 3 and 2 , i.e. we get a total time reduction factor of 6. We also use CTC auxiliary loss function  [36]  on top of the speech encoder only during training  [37] . MT model: Our MT model follows the ASR model with a 6layer BLSTM encoder without max-pooling, with a cell size of 1024. The decoder is a 1-layer unidirectional LSTM with cell size 1024, with single head additive attention equipped with alignment feedback. ST model: The encoder has a similar architecture to the ASR encoder, and the decoder is similar to the MT decoder. The models are trained end-to-end using the Adam optimizer  [38]  with a learning rate of 0.0008, and a dropout of 0.3  [39] . We warm-up the learning rate by linearly increasing it for a few training steps. Label smoothing  [40]  with a ratio of 0.1 is utilized. We employ a learning rate scheduling scheme, where we lower the learning rate with a decay factor of 0.9 if the perplexity on the dev set does not improve for 5 consecutive checkpoints and save the checkpoints every fifth of an epoch. We remove sequences longer than 75 tokens All batch sizes are specified to be as big as possible to fit in a single GPU memory. A beam size of 12 is used in inference. In order to explore the impact of SpecAugment, we choose to have relatively large models, as explained above. These models include 181M and 192M free parameters for Librispeech and IWSLT tasks respectively. The models are built using our in-house NNtoolkit software that relies on TensorFlow  [41] . The code is open source and the configurations of the setups are available online. 

 Results Table  2  and 3 present the results for the ASR and MT models (described in Section 4.2) on LibriSpeech and IWSLT tasks respectively. On the test sets, we achieve 6.47% and 13.80% WER. We note that one might gain better WER using the conventional hybrid hidden Markov model (HMM) -neural network (NN) approach on phoneme level  [42] , which is out of the scope of this paper. The MT task on LibriSpeech seems more challenging as both scores are lower. We obtain 18.2% BLEU on the LibriSpeech and respectively 31.5% BLEU on the IWSLT by pure MT. Table  4  shows the traditional cascade pipeline where the output of our ASR model, a sequence of tokens is fed as the input to our MT system. We gain 15.7% BLEU and 70.6% TER on the LibriSpeech and 24.4% BLEU and 62.5% TER on IWSLT test set. As expected, the ST systems are behind the pure MT models (cf. Table  3 and Table 4 ). In the rest of the paper, we only focus on the results of direct models.  

 Using SpecAugment In this section, we explore different types of masking. In the first set of experiments, we deactivate either time or frequency masking. The results are listed in Table  5  and 6 for LibriSpeech and IWSLT tasks respectively. As it is shown in Table  5 , we apply various types of frequency masking with different values of F, between 2 and 35, and m F while the time masking is disabled. As listed, the optimum value of F is around 4 and 5 with 1.5% in BLEU and 1.4% in TER on average of dev and test sets. A further increase of F until 20 hurts the performance by 0.4% in both BLEU and TER on the test set. To verify the effect of SpecAugment, we also employ a coarse policy where we randomly mask 35 frequency channels out of 40 and apply it 5 times. As expected, the performance drops behind the direct baseline. Interestingly enough, even a small value of frequency masking (F = 2) leads to improvements. It is important to highlight that since we randomly select the masking window between zero and maximum value of F, the results are close to each other. The best results of each set of experiments are highlighted in bold. We also disable the frequency masking by setting F and m F set to zero and vary the time mask parameter R and the number of times it has been called. Again, there is a limit of how much data augmentation can be applied. Enlarging the time masking window R to 100 leads to lower BLEU and TER scores. Furthermore, we drastically increase the time masking window R into 400 steps and apply it 5 times which fails due to unstable training. If the initial convergence is stable, in all cases, adding some data augmentation improves the setup, however, at some point, the performance degrades by more augmentation. Moreover, we observe that in many cases applying small window several times gives slightly more improvements compared to the policy in which a large window applied once (cf. row 4 and 7 in Table  5 ). After finding the optimum of both time and frequency masking, we have done some combinations of both masking as shown in the table. As expected, the combination of best of two masking gives the largest boost. We verify the influence of SpecAugment on IWSLT En?De task by an improvement up to 1.2% in BLEU and 1.8% in TER (see Table  6 ). For IWSLT, we also apply a policy similar to the LD policy of main paper  [16]  as listed in the last row of Table  6 . As shown, this setup is not the optimum case for our task, which leads to the conclusion that SpecAugment might be working better by fine-tuning on a specific task, however, adding some data augmentation improves the setup. Moreover, based on the above results, SpecAugment performs quite well regardless of the features and their dimensions. In our experiments, we use 40-dimensional Gammatone features for LibriSpeech respectively 80-dimensional MFCC features for IWSLT. In both cases, augmentation helps the performance. In the rest of   

 Importance of SpecAugment on overfitting We also study the effect of SpecAugment on overfitting. Figure  3  shows log-perplexity plots on training and dev set with and without augmentation. It is seen that SpecAugment leads to better generalization, as measured from the difference between the perplexity of training and dev data. The model trained with SpecAugment still has a training data likelihood which is higher than the baseline system. Therefore, we can confirm that the method reduces overfitting up to some degree. In this case, we need to train the SpecAugment system for few more epochs. A corresponding increase in the number of epochs for the baseline system deteriorated the performance. 

 Effect on training data size We go further and show that SpecAugment can be leveraged to improve the performance of a direct ST model, when the amount of training data is limited. To do so, we have conducted studies on a different portion of training data to see how the method performs in different data conditions. Table The minimal gains, even hurting TER when 23k samples are used. It could be attributed to the fact that 23k segments are not sufficient to train a reliable deep model. We believe that as long as a moderate amount of data is available, SpecAugment helps data efficiency more. The augmentation policy compensates lack of data when we half the training data size to 47k segments. It achieves 1.8% of absolute improvement difference in BLEU and 2.8% in TER compared to the model trained using 94k samples with 1.5% of BLEU and 1.6% of TER. 

 Pre-training We also consider the effect of data augmentation on the top of pre-training. We pre-train the using our pre-trained ASR model, and the decoder using our MT model as described in Section 4.2 which use more training data compared to the direct ST model (see Table  1 ). After initialization with pre-trained components, the ST model is fine-tuned using the ST data. Here, we add an additional BLSTM layer (adaptor layer) to adapt the output of speech encoder and the input of text decoder without freezing the parameters (see Fig.  2 ). As shown in Table  8 , SpecAugment slightly outperforms the pre-training. It outperforms the pre-trained models by 0.5% and 0.2% BLEU on LibriSpeech and IWSLT respectively, and no TER improvements. This results confirm that SpecAugment can be used along with pre-training. By comparing Table  5 and 8 , one can argue that the SpecAugment might compensate the effect of pre-training strategy by its own for LibriSpeech (compare 18.0% vs. 17.9% in BLEU on the dev set and 15.8% vs. 16.1% on the test set). We finally compare our model with the other works in the literature in Table  9 . On the LibriSpeech test set, our model outperforms both the LSTM-based end-to-end models and the Transformer-based. Contrary to  [23]  in which character decoder is used, we apply BPE that obtain improvements. Both our direct model and the cascade model outperform the models in  [23] . We also beat the Transformer models without augmentation. Our recipe works as good as knowledge distillation method where an MT model is exploited to teach the ST model. Table  9 : Comparison on LibriSpeech En?Fr test set with the literature. In order to be comparable with other works, the results in this table are case-insensitive BLEU computed using multi-bleu.pl script  [29] .  1  : the evaluation is without punctuation.  2  : it correspond to 16.2% BLEU from Table  8 . 

 Method BLEU [%] other works direct  [23]  13.3 multi-task  [23]  13.4 cascade pipeline  [23]  14.6 unsupervised 1  [30]  12.2 Transformer  [20]  13.8 Transformer+pretraining  [21]  14.3 + knowledge distillation  [21]  17.0 this work direct+pretraining+SpecAugment 2 17.0 

 Conclusion We have studied SpecAugment, a simple and low-cost data augmentation for end-to-end direct speech translation. There is a limit of how much data augmentation can be applied. Adding some data augmentation improves the performance in terms of BLEU and TER, however, at some point, the performance degrades by more augmentation. We have also shown that the method avoids overfitting to some extent and it requires longer training. A common criticism of many techniques for low-resource applications is that the improvements go away once we have lots of synthetic parallel data. Therefore, we believe that comparing the SpecAugment approach with generated data using TTS model is a crucial next step. We also aim to explore the effectiveness of the approach on Transformer architecture. 
