title
Chunk-based Decoder for Neural Machine Translation

abstract
Chunks (or phrases) once played a pivotal role in machine translation. By using a chunk rather than a word as the basic translation unit, local (intrachunk) and global (inter-chunk) word orders and dependencies can be easily modeled. The chunk structure, despite its importance, has not been considered in the decoders used for neural machine translation (NMT). In this paper, we propose chunk-based decoders for NMT, each of which consists of a chunk-level decoder and a word-level decoder. The chunklevel decoder models global dependencies while the word-level decoder decides the local word order in a chunk. To output a target sentence, the chunk-level decoder generates a chunk representation containing global information, which the wordlevel decoder then uses as a basis to predict the words inside the chunk. Experimental results show that our proposed decoders can significantly improve translation performance in a WAT '16 Englishto-Japanese translation task.

Introduction Neural machine translation (NMT) performs endto-end translation based on a simple encoderdecoder model  (Kalchbrenner and Blunsom, 2013; Sutskever et al., 2014; Cho et al., 2014b)  and has now overtaken the classical, complex statistical machine translation (SMT) in terms of performance and simplicity  (Sennrich et al., 2016; Luong and Manning, 2016; Cromieres et al., 2016; Neubig, 2016) . In NMT, an encoder first maps a source sequence into vector representations and * Contribution during internship at Microsoft Research. a decoder then maps the vectors into a target sequence ( ? 2). This simple framework allows researchers to incorporate the structure of the source sentence as in SMT by leveraging various architectures as the encoder  (Kalchbrenner and Blunsom, 2013; Sutskever et al., 2014; Cho et al., 2014b; Eriguchi et al., 2016b) . Most of the NMT models, however, still rely on a sequential decoder based on a recurrent neural network (RNN) due to the difficulty in capturing the structure of a target sentence that is unseen during translation. With the sequential decoder, however, there are two problems to be solved. First, it is difficult to model long-distance dependencies  (Bahdanau et al., 2015) . A hidden state h t in an RNN is only conditioned by its previous output y t?1 , previous hidden state h t?1 , and current input x t . This makes it difficult to capture the dependencies between an older output y t?N if they are too far from the current output. This problem can become more serious when the target sequence becomes longer. For example, in Figure  1 , when we translate the English sentence into the Japanese one, after the decoder predicts the content word "? (go back)", it has to predict four function words "? (suffix)", "? (perfect tense)", "? (desire)", and "? (to)" before predicting the next content word "? (feel)". In such a case, the decoder is required to capture the longer dependencies in a target sentence. Another problem with the sequential decoder is that it is expected to cover multiple possible word orders simply by memorizing the local word se-quences in the limited training data. This problem can be more serious in free word-order languages such as Czech, German, Japanese, and Turkish. In the case of the example in Figure  1 , the order of the phrase "? (early)" and the phrase "? (to home)" is flexible. This means that simply memorizing the word order in training data is not enough to train a model that can assign a high probability to a correct sentence regardless of its word order. In the past, chunks (or phrases) were utilized to handle the above problems in statistical machine translation (SMT)  (Watanabe et al., 2003; Koehn et al., 2003)  and in example-based machine translation (EBMT)  (Kim et al., 2010) . By using a chunk rather than a word as the basic translation unit, one can treat a sentence as a shorter sequence. This makes it easy to capture the longer dependencies in a target sentence. The order of words in a chunk is relatively fixed while that in a sentence is much more flexible. Thus, modeling intra-chunk (local) word orders and inter-chunk (global) dependencies independently can help capture the difference of the flexibility between the word order and the chunk order in free word-order languages. In this paper, we refine the original RNN decoder to consider chunk information in NMT. We propose three novel NMT models that capture and utilize the chunk structure in the target language ( ? 3). Our focus is the hierarchical structure of a sentence: each sentence consists of chunks, and each chunk consists of words. To encourage an NMT model to capture the hierarchical structure, we start from a hierarchical RNN that consists of a chunk-level decoder and a word-level decoder (Model 1). Then, we improve the word-level decoder by introducing inter-chunk connections to capture the interaction between chunks (Model 2). Finally, we introduce a feedback mechanism to the chunk-level decoder to enhance the memory capacity of previous outputs (Model 3). We evaluate the three models on the WAT '16 English-to-Japanese translation task ( ? 4). The experimental results show that our best model outperforms the best single NMT model reported in WAT '16  (Eriguchi et al., 2016b) . Our contributions are twofold: (1) chunk information is introduced into NMT to improve translation performance, and (2) a novel hierarchical decoder is devised to model the properties of chunk structure in the encoder-decoder framework. 

 Preliminaries: Attention-based Neural Machine Translation In this section, we briefly introduce the architecture of the attention-based NMT model  (Bahdanau et al., 2015) , which is the basis of our proposed models. 

 Neural Machine Translation An NMT model usually consists of two connected neural networks: an encoder and a decoder. After the encoder maps a source sentence into a fixed-length vector, the decoder maps the vector into a target sentence. The implementation of the encoder can be a convolutional neural network (CNN)  (Kalchbrenner and Blunsom, 2013) , a long short-term memory (LSTM)  (Sutskever et al., 2014; Luong and Manning, 2016) , a gated recurrent unit (GRU)  (Cho et al., 2014b; Bahdanau et al., 2015) , or a Tree-LSTM  (Eriguchi et al., 2016b) . While various architectures are leveraged as an encoder to capture the structural information in the source language, most of the NMT models rely on a standard sequential network such as LSTM or GRU as the decoder. Following  (Bahdanau et al., 2015) , we use GRU as the recurrent unit in this paper. A GRU unit computes its hidden state vector h i given an input vector x i and the previous hidden state h i?1 : h i = GRU(h i?1 , x i ). (1) The function GRU(?) is calculated as r i = ?(W r x i + U r h i?1 + b r ), (2) z i = ?(W z x i + U z h i?1 + b z ), (3) hi = tanh(W x i + U (r i h i?1 + b)), (4) h i = (1 ? z i ) hi + z i h i?1 , (5) where vectors r i and z i are reset gate and update gate, respectively. While the former gate allows the model to forget the previous states, the latter gate decides how much the model updates its content. All the W s and U s, or the bs above are trainable matrices or vectors. ?(?) and denote the sigmoid function and element-wise multiplication operator, respectively. In this simple model, we train a GRU function that encodes a source sentence {x 1 , ? ? ? , x I } into a single vector h I . At the same time, we jointly train another GRU function that decodes h I to the target sentence {y 1 , ? ? ? , y J }. Here, the j-th word in the ! " ? ? ? # " !"#$%&'( )*%%&"( +,-,&+ $ % . / )&-'% & ' . . $ ( $ ' . . ) % ) ( ) " )* % )* ( )* " target sentence y j can be predicted with this decoder GRU and a nonlinear function g(?) followed by a softmax layer, as c = h I , (6) s j = GRU(s j?1 , [y j?1 ; c]), (7) sj = g(y j?1 , s j , c), (8) P (y j |y <j , x) = softmax(s j ), (9) where c is a context vector of the encoded sentence and s j is a hidden state of the decoder GRU. Following  Bahdanau et al. (2015) , we use a mini-batch stochastic gradient descent (SGD) algorithm with ADADELTA (Zeiler, 2012) to train the above two GRU functions (i.e., the encoder and the decoder) jointly. The objective is to minimize the cross-entropy loss of the training data D, as J = (x,y)?D ? log P (y|x). (10) 

 Attention Mechanism for Neural Machine Translation To use all the hidden states of the encoder and improve the translation performance of long sentences,  Bahdanau et al. (2015)  proposed using an attention mechanism. In the attention model, the context vector is not simply the last encoder state h I but rather the weighted sum of all hidden states of the bidirectional GRU, as follows: c j = I i=1 ? ji h i . (11) Here, the weight ? ji decides how much a source word x i contributes to the target word y j . ? ji is computed by a feedforward layer and a softmax layer as where W e , U e are trainable matrices and the v, b e are trainable vectors. 1 In a decoder using the attention mechanism, the obtained context vector c j in each time step replaces cs in Eqs. (  7 ) and (  8 ). An illustration of the NMT model with the attention mechanism is shown in Figure  2 . e ji = v ? tanh(W e h i + U e s j + b e ), (12) ? ji = exp(e ji ) J j =1 exp(e j i ) , (13) The attention mechanism is expected to learn alignments between source and target words, and plays a similar role to the translation model in phrase-based SMT  (Koehn et al., 2003) . 

 Neural Machine Translation with Chunk-based Decoder Taking non-sequential information such as chunks (or phrases) structure into consideration has proved helpful for SMT  (Watanabe et al., 2003; Koehn et al., 2003)  and EBMT  (Kim et al., 2010) . Here, we focus on two important properties of chunks (Abney, 1991): (1) The word order in a chunk is almost always fixed, and (2) A chunk consists of a few (typically one) content words surrounded by zero or more function words. To fully utilize the above properties of a chunk, we propose modeling the intra-chunk and the inter-chunk dependencies independently with a "chunk-by-chunk" decoder (See Figure  3 ). In the standard word-by-word decoder described in ? 2, a target word y j in the target sentence y is predicted by taking the previous outputs y <j and the source sentence x as input: P (y|x) = J j=1 P (y j |y <j , x), ( 14 ) where J is the length of the target sentence. Not assuming any structural information of the target language, the sequential decoder has to memorize long dependencies in a sequence. To release the model from the pressure of memorizing the long dependencies over a sentence, we redefine this problem as the combination of a word prediction problem and a chunk generation problem: ! "#$ !"#$%&'('& )'*"$'#+ ,!-./.0+ 1 % "#& '() % "#* '() 23456++ 23456+, -+ 23456+, % "#$ '() %. "#$ '() ? ? ? ? ? ? %. "#& '() %. "#* '() / "#$ % "0&# 1 '() / "0&# P (y|x) = K k=1 ? ? ? P (c k |c <k , x) J k j=1 P (y j |y <j , c k , x) ? ? ? , ( 15 ) where K is the number of chunks in the target sentence and J k is the length of the k-th chunk (see Figure  3 ). The first term represents the generation probability of a chunk c k and the second term indicates the probability of a word y j in the chunk. We model the former term as a chunk-level decoder and the latter term as a word-level decoder. As demonstrated later in ? 4, both K and J k are much shorter than the sentence length J, which is why our decoders do not have to capture the long dependencies like the standard decoder does. In the above formulation, we model the information of words and their orders in a chunk. No matter which language we target, we can assume that a chunk usually consists of some content words and function words, and the word order in the chunk is almost always fixed  (Abney, 1991) . Although our idea can be used in several languages, the optimal network architecture could depend on the word order of the target language. In this work, we design models for lan-guages in which content words are followed by function words, such as Japanese and Korean. The details of our models are described in the following sections. 

 Model 1: Basic Chunk-based Decoder The model described in this section is the basis of our proposed decoders. It consists of two parts: a chunk-level decoder ( ? 3.1.1) and a word-level decoder ( ? 3.1.2). The part drawn in black solid lines in Figure  4  illustrates the architecture of Model 1. 

 Chunk-level Decoder Our chunk-level decoder (see Figure  3 ) outputs a chunk representation. The chunk representation contains the information about words that should be predicted by the word-level decoder. To generate the representation of the k-th chunk s(c) k , the chunk-level decoder (see the bottom layer in Figure  4 ) takes the last states of the word-level decoder s (w) k?1,J k?1 and updates its hidden state s (c) k as: s (c) k = GRU(s (c) k?1 , s (w) k?1,J k?1 ), (16) s(c) k = W c s (c) k + b c . ( 17 ) The obtained chunk representation s(c) k continues to be fed into the word-level decoder until it outputs all the words in the current chunk. 

 Word-level Decoder Our word-level decoder (see Figure  4 ) differs from the standard sequential decoder described in ? 2 in that it takes the chunk representation s(c) k as input: s (w) k,j = GRU(s (w) k,j?1 , [s (c) k ; y k,j?1 ; c k,j?1 ]), (18) s(w) k,j = g(y k,j?1 , s (w) k,j , c k,j ), (19) P (y k,j |y <j , x) = softmax(s (w) k,j ). (20) In a standard sequential decoder, the hidden state iterates over the length of a target sentence and then generates an end-of-sentence token. In other words, its hidden layers are required to memorize the long-term dependencies and orders in the target language. In contrast, in our word-level decoder, the hidden state iterates only over the length of a chunk and then generates an end-of-chunk token. Thus, our word-level decoder is released from the pressure of memorizing the long (interchunk) dependencies and can focus on learning the short (intra-chunk) dependencies. 

 Model 2: Inter-Chunk Connection The second term in Eq. (  15 ) only iterates over one chunk (j = 1 to J k ). This means that the last state and the last output of a chunk are not being fed into the word-level decoder at the next time step (see the black part in Figure  4 ). In other words, s k,1 in Eq. (  18 ) is always initialized before generating the first word in a chunk. This may have a bad influence on the word-level decoder because it cannot access any previous information at the first word of each chunk. To address this problem, we add new connections to Model 1 between the first state in a chunk and the last state in the previous chunk, as s (w) k,1 = GRU(s (w) k?1,J k?1 , [s (c) k ; y k?1,J k?1 ; c k?1,J k?1 ]). (21) The dashed blue arrows in Figure  4  illustrate the added inter-chunk connections. 

 Model 3: Word-to-Chunk Feedback The chunk-level decoder in Eq. (  16 ) is only conditioned by s (w) k?1,J k?1 , the last word state in each chunk (see the black part in Figure  4 ). This may affect the chunk-level decoder because it cannot memorize what kind of information has already been generated by the word-level decoder. The information about the words in a chunk should not be included in the representation of the next chunk; otherwise, it may generate the same chunks multiple times, or forget to translate some words in the source sentence. To encourage the chunk-level decoder to memorize the information about the previous outputs more carefully, we add feedback states to our chunk-level decoder in Model 2. The feedback state in the chunk-level decoder is updated at every time step j(> 1) in k-th chunk, as s (c) k,j = GRU(s (c) k,j?1 , s (w) k,j ). ( 22 ) The red part in Figure  4  illustrate the added feedback states and their connections. The connections in the thick black arrows are replaced with the dotted red arrows in Model 3. 

 Experiments 

 Setup Data To examine the effectiveness of our decoders, we chose Japanese, a free word-order language, as the target language. Japanese sentences are easy to break into well-defined chunks (called bunsetsus  (Hashimoto, 1934)  in Japanese). For example, the accuracy of bunsetsu-chunking on newspaper articles is reported to be over 99%  (Murata et al., 2000; Yoshinaga and Kitsuregawa, 2014) . The effect of chunking errors in training the decoder can be suppressed, which means we can accurately evaluate the potential of our method. We used the English-Japanese training corpus in the Asian Scientific Paper Excerpt Corpus (ASPEC) , which was provided in WAT '16. To remove inaccurate translation pairs, we extracted the first two million out of the 3 million pairs following the setting that gave the best performances in WAT '15  (Neubig et al., 2015) . Preprocessings For Japanese sentences, we performed tokenization using KyTea 0.4.7 2  (Neubig et al., 2011) . Then we performed bunsetsuchunking with J.DepP 2015.10.05 3  (Yoshinaga and Kitsuregawa, 2009 . Special endof-chunk tokens were inserted at the end of the chunks. Our word-level decoders described in ? 3 will stop generating words after each endof-chunk token. For English sentences, we performed the same preprocessings described on the WAT '16 Website.  4   The maximum number of chunks in the target sentence is larger than 20 (3% of whole data). Table  1  shows the details of the extracted data. Postprocessing To perform unknown word replacement  (Luong et al., 2015a) , we built a bilingual English-Japanese dictionary from all of the three million translation pairs. The dictionary was extracted with the MGIZA++ 0.7.0 5  (Och and Ney, 2003; Gao and Vogel, 2008)  word alignment tool by automatically extracting the alignments between English words and Japanese words. Model Architecture Any encoder can be combined with our decoders. In this work, we adopted a single-layer bidirectional GRU  (Cho et al., 2014b; Bahdanau et al., 2015)  as the encoder to focus on confirming the impact of the proposed decoders. We used single layer GRUs for the wordlevel decoder and the chunk-level decoder. The vocabulary sizes were set to 40k for source side and 30k for target side, respectively. The conditional probability of each target word was computed with a deep-output  (Pascanu et al., 2014)  layer with maxout  (Goodfellow et al., 2013)  units following  (Bahdanau et al., 2015) . The maximum number of output chunks was set to 20 and the maximum length of a chunk was set to 8. 

 Training Details The models were optimized using ADADELTA following  (Bahdanau et al., 2015) . The hyperparameters of the training procedure were fixed to the values given in Table  2 . Note that the learning rate was halved when the BLEU score on the development set did not in- crease for 30,000 batches. All the parameters were initialized randomly with Gaussian distribution. It took about a week to train each model with an NVIDIA TITAN X (Pascal) GPU. Evaluation Following the WAT '16 evaluation procedure, we used BLEU  (Papineni et al., 2002)  and RIBES  (Isozaki et al., 2010)  to evaluate our models. The BLEU scores were calculated with multi-bleu.pl in Moses 2.1.1 6  (Koehn et al., 2007) ; RIBES scores were calculated with RIBES.py 1.03.1 7  (Isozaki et al., 2010) . Following  Cho et al. (2014a) , we performed beam search 8 with length-normalized log-probability to decode target sentences. We saved the trained models that performed best on the development set during training and used them to evaluate the systems with the test set. 

 Baseline Systems The baseline systems and the important hyperparamters are listed in Table  3 .  Eriguchi et al. (2016a) 's baseline system (the first line in Table  3 ) was the best single (w/o ensembling) word-based NMT system that were reported in WAT '16. For a more fair evaluation, we also reimplemented a standard attention-based NMT system that uses exactly the same encoder, training procedure, and the hyperparameters as our proposed models, but has a word-based decoder. We trained this system on the training data without chunk segmentations (the second line in Table  3 ) and with chunk segmentations given by J.DepP (the third line in Table  3 ). The chunked corpus fed to the third system is exactly the same as the training data of our proposed systems (sixth to eighth lines in Table  3 ). In addition, we also include the Tree-to-Sequence models  (Eriguchi et al., 2016a,b)  (the fourth and fifth lines in Table  3 ) to compare the impact of capturing the structure in the source language and that in the target language. Note that all systems listed in Table  3 , including our models, are single models without ensemble techniques. 

 Results Proposed Models vs. Baselines Table  3   This result shows that capturing the chunk structure in the target language is more effective than capturing the syntax structure in the source language. Compared with the character-based NMT model  (Eriguchi et al., 2016a) , our Model 3 performed better by +5.74 BLEU score and +2.84 RIBES score. One possible reason for this is that using a character-based model rather than a wordbased model makes it more difficult to capture long-distance dependencies because the length of a target sequence becomes much longer in the character-based model. Comparison between Baselines Among the five baselines, our reimplementation without chunk segmentations (the second line in Table  3 ) achieved the best BLEU score while the Eriguchi et al. (2016b)'s system (the fourth line in Table  3 ) achieved the best RIBES score. The most probable reasons for the superiority of our reimplementation over the  Eriguchi et al. (2016a) 's word-based baseline (the first line in Table  3 ) is that the dimensions of word embeddings and hidden states in our systems are higher than theirs. Feeding chunked training data to our baseline system (the third line in Table  3 ) instead of a normal data caused bad effects by ?0.62 BLEU score and by ?0.33 RIBES score. We evaluated the chunking ability of this system by comparing the positions of end-of-chunk tokens generated by this system with the chunk boundaries obtained by J.DepP. To our surprise, this word-based decoder could output chunk separations as accurate as our proposed Model 3 (both systems achieved F 1 -score > 97). The results show that even a standard word-based decoder has the ability to predict chunk boundaries if they are given in training data. However, it is difficult for the word-based decoder to utilize the chunk information to improve the translation quality. Decoding Speed Although the chunk-based decoder runs 2x slower than our word-based decoder, it is still practically acceptable (6 sentences per second). The character-based decoder (the fifth line in Table  3 ) is less time-consuming mainly because of its small vocabulary size (|V trg | = 3k). 

 Chunk-level Evaluation To confirm that our models can capture local (intra-chunk) and global (inter-chunk) word orders well, we evaluated the translation quality at the chunk level. First, we performed bunsetsu-chunking on the reference translations in the test set. Then, for both reference translations and the outputs of our systems, we combined all the words in each chunk into a single token to regard a chunk as the basic translation unit instead of a word. Finally, we computed the chunk-based BLEU (C-BLEU) and RIBES  (C-RIBES). The results are listed in Table  4 . For the word-based decoder (the first line in Table  4 ), we performed bunsetsu-chunking by J.DepP on its outputs to obtain chunk boundaries. As another baseline (the second line in Table  4 ), we used the chunked sentences as training data instead of performing chunking after decoding. The results show that our models (Model 2 and Model 3) outperform the word-based decoders in both C-BLEU and C-RIBES. This indicates that our chunk-based decoders can produce more correct chunks in a more correct order than the word-based models. !"# $%&!'(# )*# "+'&',- !"# $%&!'(# !.'# # !'/.+012' &3'/0%,# %452&!$'+! !"# $%&!'(# "6+# !'/.+012' &3'/0%,,*# 40--0/2,! &3'/0%,,*# 40--0/2,! !"# $%&!'(# "6+# !'/.+012' &3'/0%,,*# 40--0/2,! &3'/0%,# 7%458# 40--0/2,! !"# $%&!'(# !.'# !'/.+012'# )*#"+'&',- 90+/'#&3'/0%,,*#40--0/2,!#3"0+!&#%('#-'6#-"(#!.'#%452&!$'+!#:#0!#0&#0$3"(!%+!#!"#$%&!'(#!.'#!'/.+012'#)*#"+'&',-#; !"#$%&< '&(&$&)%&< !" # ? ? ? ?$# %& ' ( Qualitative Analysis To clarify the qualitative difference between the word-based decoder and our chunk-based decoders, we show translation examples in Figure  5 . Words in blue and red respectively denote correct translations and wrong translations. The word-based decoder (our implementation) has completely dropped the translation of "by oneself." On the other hand, Model 1 generated a slightly wrong translation "? (to master own technique)." In addition, Model 1 has made another serious word-order error "? (special adjustment)." These results suggest that Model 1 can capture longer dependencies in a long sequence than the word-based decoder. However, Model 1 is not good at modeling global word order because it cannot access enough information about previous outputs. The weakness of modeling word order was overcome in Model 2 thanks to the inter-chunk connections. However, Model 2 still suffered from the errors of function words: it still generates a wrong chunk "? (special)" instead of the correct one "? (specially)" and a wrong chunk "? ?" instead of "? ?." Although these errors seem trivial, such mistakes with function words bring serious changes of sentence meaning. However, all of these problems have disappeared in Model 3. This phenomenon supports the importance of the feedback states to provide the decoder with a better ability to choose more accurate words in chunks. 

 Related Work Much work has been done on using chunk (or phrase) structure to improve machine translation quality. The most notable work involved phrasebased SMT  (Koehn et al., 2003)  While most of the NMT models focus on the conversion between sequential data, some works have tried to incorporate non-sequential informa-tion into NMT  (Eriguchi et al., 2016b; Su et al., 2017) .  Eriguchi et al. (2016b)  use a Tree-based LSTM  (Tai et al., 2015)  to encode input sentence into context vectors. Given a syntactic tree of a source sentence, their tree-based encoder encodes words from the leaf nodes to the root nodes recursively.  Su et al. (2017)  proposed a lattice-based encoder that considers multiple tokenization results while encoding the input sentence. To prevent the tokenization errors from propagating to the whole NMT system, their attice-based encoder can utilize multiple tokenization results. These works focus on the encoding process and propose better encoders that can exploit the structures of the source language. In contrast, our work focuses on the decoding process to capture the structure of the target language. The encoders described above and our proposed decoders are complementary so they can be combined into a single network. Considering that our Model 1 described in ? 3.1 can be seen as a hierarchical RNN, our work is also related to previous studies that utilize multi-layer RNNs to capture hierarchical structures in data. Hierarchical RNNs are used for various NLP tasks such as machine translation  (Luong and Manning, 2016) , document modeling  Lin et al., 2015) , dialog generation  (Serban et al., 2017) , image captioning  (Krause et al., 2016) , and video captioning  (Yu et al., 2016) . In particular,  and  Luong and Manning (2016)  use hierarchical encoder-decoder models, but not for the purpose of learning syntactic structures of target sentences.  build hierarchical models at the sentence-word level to obtain better document representations.  Luong and Manning (2016)  build the word-character level to cope with the out-of-vocabulary problem. In contrast, we build a hierarchical models at the chunk-word level to explicitly capture the syntactic structure based on chunk segmentation. In addition, the architecture of Model 3 is also related to stacked RNN, which has shown to be effective in improving the translation quality  (Luong et al., 2015a; Sutskever et al., 2014) . Although these architectures look similar to each other, there is a fundamental difference between the directions of the connection between two layers. A stacked RNN consists of multiple RNN layers that are connected from the input side to the output side at every time step. In contrast, our Model 3 has a different connection at each time step. Before it gen-erates a chunk, there is a feed-forward connection from the chunk-level decoder to the word-level decoder. However, after generating a chunk representation, the connection is to be reversed to feed back the information from the word-level decoder to the chunk-level decoder. By switching the connections between two layers, our model can capture the chunk structure explicitly. This is the first work that proposes decoders for NMT that can capture plausible linguistic structures such as chunk. Finally, we noticed that (Zhou et al., 2017) (which is accepted at the same time as this paper) have also proposed a chunk-based decoder for NMT. Their good experimental result on Chinese to English translation task also indicates the effectiveness of "chunk-by-chunk" decoders. Although their architecture is similar to our Model 2, there are several differences: (1) they adopt chunk-level attention instead of word-level attention; (2) their model predicts chunk tags (such as noun phrase), while ours only predicts chunk boundaries; and (3) they employ a boundary gate to decide the chunk boundaries, while we do that by simply having the model generate end-of-chunk tokens. 

 Conclusion In this paper, we propose chunk-based decoders for NMT. As the attention mechanism in NMT plays a similar role to the translation model in phrase-based SMT, our chunk-based decoders are intended to capture the notion of chunks in chunkbased (or phrase-based) SMT. We utilize the chunk structure to efficiently capture long-distance dependencies and cope with the problem of free word-order languages such as Japanese. We designed three models that have hierarchical RNNlike architectures, each of which consists of a word-level decoder and a chunk-level decoder. We performed experiments on the WAT '16 Englishto-Japanese translation task and found that our best model outperforms the strongest baselines by +0.93 BLEU score and by +0.57 RIBES score. In future work, we will explore the optimal structures of chunk-based decoder for other free word-order languages such as Czech, German, and Turkish. In addition, we plan to combine our decoder with other encoders that capture language structure, such as a hierarchical RNN  (Luong and Manning, 2016) , a Tree-LSTM  (Eriguchi et al., 2016b) , or an order-free encoder, such as a CNN  (Kalchbrenner and Blunsom, 2013) . Figure 1 : 1 Figure 1: Translation from English to Japanese. The function words are underlined. 
