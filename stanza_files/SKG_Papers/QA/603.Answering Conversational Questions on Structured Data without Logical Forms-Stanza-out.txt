title
Answering Conversational Questions on Structured Data without Logical Forms
abstract
We present a novel approach to answering sequential questions based on structured objects such as knowledge bases or tables without using a logical form as an intermediate representation .
We encode tables as graphs using a graph neural network model based on the Transformer architecture .
The answers are then selected from the encoded graph using a pointer network .
This model is appropriate for processing conversations around structured data , where the attention mechanism that selects the answers to a question can also be used to resolve conversational references .
We demonstrate the validity of this approach with competitive results on the Sequential Question Answering ( SQA ) task ( Iyyer et al. , 2017 ) .
Introduction
In recent years , there has been significant progress on conversational question answering ( QA ) , where questions can be meaningfully answered only within the context of a conversation ( Iyyer et al. , 2017 ; Choi et al. , 2018 ; Saha et al. , 2018 ) .
This line of work , as in single QA setup , falls into two main categories , ( i ) the answers are extracted from some text in a reading comprehension setting , ( ii ) the answers are extracted from structured objects , such as knowledge bases or tables .
The latter is commonly posed as a semantic parsing task , where the goal is to map questions to some logical form which is then executed over the knowledge base to extract the answers .
In semantic parsing , there is extensive work on using deep neural networks for training models over manually created logical forms in a supervised learning setup ( Jia and Liang , 2016 ; Ling et al. , 2016 ; Dong and Lapata , 2018 ) .
However , creating labeled data for this task can be expensive and time - consuming .
This problem resulted in research that investigates semantic parsing with weak supervision where training data consists of questions and answers along with the structured resources to recover the logical form representations that would yield the correct answer Iyyer et al. , 2017 ) .
In this paper , we follow this line of research and investigate answering sequential questions with respect to structured objects .
In contrast to previous approaches , instead of learning the intermediate logical forms , we propose a novel approach that encodes the structured resources , i.e. tables , along with the questions and answers from the context of the conversation .
This approach allows us to handle conversational context without the definition of detailed operations or a vocabulary dependent on the logical form formalism that are required in the weakly supervised semantic parsing approaches .
We present empirical performance of the proposed approach on the Sequential Question Answering task ( SQA ) ( Iyyer et al. , 2017 ) which improves the state - of - the - art performance on all questions , particularly on the follow - up questions that require effective encoding of the context .
Approach
We build a QA model for a sequence of questions that are asked about a table and can be answered by selecting one or more table cells .
Graph Formulation
We encode tables as graphs by representing columns , rows and cells as nodes .
Figure 1 shows an example graph representing how we encode the table in relation to q 2 , which is the follow up question to q 1 .
Within a column , cells with identical texts are collapsed into a single node .
In the example graph , we only create a single node for " Toronto " and a single node for " Montreal " .
We then add 4 directed edges that connect columns Additionally numerical cells are annotated with their numerical rank and inverse rank with respect to the column ( small blue boxes ) .
The answer column , rows and cells of q 1 are also marked ( nodes with borders ) .
and rows to cells , one in either direction ( orange and green edges in the figure ) .
The question is represented by a node covering the entire question text and a node for each token .
The main question node is connected to each token , column and cell node .
1 Nodes have associated nominal feature sets .
All nodes have a feature indicating their type : column , row , cell , question and question token .
The text in column ( i.e. , the column name ) , cell , question and token nodes are added to the corresponding node feature set adopting a bag-of-words representation .
Column , row and cell nodes have additional features that indicate their column ( for cell and column nodes ) and row ( for cell and row nodes ) indexes .
We align question tokens with column names and cell text using the Levenshtein edit distance between n-grams in the question and the table text , similar to previous work ( Shaw et al. , 2019 ) .
In particular , we score every question n-gram with the normalized edit distance 2 and connect the cell to the token span if the score is > 0.5 .
Through the alignment , the cell is connected to all the tokens of the matching span and the binned score is added as an additional feature to the cell .
In Figure 1 , the " building " and " floors " tokens in the questions are connected to the matching " Building " and " Floors " column nodes from the table .
1 We do not show some of these connections in the figure to avoid clutter .
2 ned( v , w ) = ed ( v, w ) max ( | v| , |w | ) Numeric Operations
In order to allow operations over numbers and date expressions , we extend our graph with a set of relations involving numerical values in the question and table cells .
We infer the type of the numerical values in a column , such as the ones in the " Floors " column , by picking their most frequent type ( number or date ) .
Then , we add special features to each cell in the column : the rank and inverse rank of the value in the cell , considering the other cell values from the same column .
These features allow the model to answer questions such as " what is the building with most floors ? " .
In addition , we add a new node to the graph for each numeric expression from the question ( such as the number 60 from the second question in Figure 1 ) , and we connect it to the tokens it spans .
The numerical nodes originated from the question are connected to the table cells containing numerical values .
The connection type encodes the result of the comparison between the question and cell values , lesser , greater or equal , as shown in the figure ( yellow edges ) .
This relations allow the model to answer questions such as " which buildings have more than 50 floors ? " .
Context
We extend the model to capture conversational context by using the feature - based encoding in the graph formulation .
In order to handle follow - up questions , we add the previous answers to the graph by marking all the answer rows , columns and cells with nominal features .
The nodes with borders in Figure 1 contain the answers to the first question q 1 : " what are the buildings in toronto ? " .
In the example , the first two rows receive a feature ANSWER ROW , the " building " column a feature ANSWER COLUMN and " First Canadian Place " and " Commerce Court West " a feature ANSWER CELL .
Notice that the content of q 1 is not encoded in the graph , only its answers .
Node Representations
Before the initial encoder layer , all nodes are mapped to vector representations using learned embeddings .
For nodes with multiple features , such as column and cell nodes , we reduce the set of feature embeddings to a single vector using the mean .
We also concatenate an embedding encoding whether the node represents a question token , or not .
Encoder
We use a Graph Neural Network ( GNN ) encoder based on the Transformer ( Vaswani et al. , 2017 ) .
The only modification is that the self-attention mechanism is extended to consider the edge label between each pair of nodes .
We follow the formulation of Shaw et al . ( 2019 ) that uses additive edge vector representations .
The self-attention weights are therefore calculated as : s ij = ( W q x i ) ( W k x j + r ij ) , ( 1 ) where s ij is the unnormalized attention weight for the node vector representations x i and x j , and W q and W k are parameter matrices .
This extension introduces r ij to the calculation , which is a vector representation of the edge label between the two nodes .
Edge vectors are similarly added when summing over node representations to produce the new output representations .
We use edge labels corresponding to relative positions between tokens , alignments between tokens and table elements , and relations between table elements , as described in Section 2.1 .
These amount to 9 fixed edge labels in the graph ( 4 between rows / cells / columns , 2 between question and cells / columns , and 3 numeric relations ) and a tunable number of relative token positions ) .
Answer Selection
We extend the Transformer decoder to include a copy mechanism based on a pointer network ( Vinyals et al. , 2015 ) .
The copy mechanism allows the model to predict sequences of answer columns and rows from the input , rather than select symbols from an output vocabulary .
Figure 2 visualizes the entire model architecture .
Related Work Semantic parsing models can be trained to produce gold logical forms using an encoder-decoder approach ( Suhr et al. , 2018 ) or by filling templates ( Xu et al. , 2017 ; Peng et al. , 2017 ; .
When gold logical forms are not available , they are typically treated as latent variables or hidden states and the answers or denotations are used to search for correct logical forms ( Yih et al. , 2015 ; Long et al. , 2016 ; Iyyer et al. , 2017 ) .
In some cases , feedback from query execution is used as a reward signal for updating the model through reinforcement learning ( Zhong et al. , 2017 ; Agarwal et al. , 2019 ) or for refining parts of the query ( Wang et al. , 2018 ) .
In our work , we do not use logical forms or RL , which can be hard to train , but simplify the training process by directly matching questions to table cells .
Most of the QA and semantic parsing research focuses on single turn questions .
We are interested in handling multiple turns and therefore in modeling context .
In semantic parsing tasks , logical forms ( Iyyer et al. , 2017 ; Sun et al. , 2018 b ; Guo et al. , 2018 ) or SQL statements ( Suhr et al. , 2018 ) from previous questions are refined to handle follow up questions .
In our model , we encode answers to previous questions by marking answer rows , columns and cells in the table , in a nonautoregressive fashion .
In regards to how structured data is represented , methods range from encoding table information , metadata and / or content , ( Gur et al. , 2018 ; Sun et al. , 2018 b ; Petrovski et al. , 2018 ) to encoding relations between the question and table items ( Krishnamurthy et al. , 2017 ) or KB entities ( Sun et al. , 2018a ) .
We also encode the table structure and the question in an annotation graph , but use a different modelling approach .
Experimental Setup
We evaluate our method on the SequentialQA ( SQA ) dataset ( Iyyer et al. , 2017 ) , which consists of sequences of questions that can be answered from a given table .
The dataset is designed so that every question can be answered by one or more table cells .
It consists of 6 , 066 answer sequences containing 17553 questions ( 2.9 question per sequence on average ) .
Table 2 shows an example .
We lowercase and remove punctuation from questions , cell texts and column names .
We then split each input utterance on spaces to generate a sequence of tokens .
3
We only keep the most frequent 5 , 000 word types and map everything else to one of 2 , 000 OOV buckets .
Numbers and dates are parsed in a similar way as in the DynSp and the Neural Programmer ( Neelakantan et al. , 2016 a ) .
We use the Adam optimizer ( Kingma and Ba , 2014 ) for optimization and tune hyperparameters with Google Vizier ( Golovin et al. , 2017 ) .
More details and the hyperparameter ranges can be found in the appendix ( A ) .
All numbers given for our model are averaged over 5 independent runs with different random initializations .
Results
We compare our model to Float Parser ( FP ) ( Pasupat and Liang , 2015 ) , Neural Programmer ( NP ) ( Neelakantan et al. , 2016 b ) , DYNSP ( Iyyer et al. , 2017 ) and CAMP ( Sun et al. , 2018 b ) in Table 1 . We observe that our model improves the SOTA from 45.6 % by CAMP to 55.1 % in question accuracy ( ALL ) , reducing the relative error rate by 18 % .
For the initial question ( POS1 ) , however , it is behind DYNSP by 3.7 % .
More interestingly , our model handles follow up questions especially well outperforming the previously best model FP by 20 % on POS3 , a 28 % relative error reduction .
As in previous work , we also report performance for a non-contextual setup where follow up questions are answered in isolation .
We observe that our model effectively leverages the context information by improving the average question accuracy from 45.1 % to 55.1 % in comparison to the use of context in DYNSP yielding 2.7 % improvement .
If we provide the previous reference answers , the average question accuracy jumps to 61.7 % , showing that 6.6 % of the errors are due to error propagation .
Numeric operations
For understanding how effective our model is in handling numeric operations , we trained models without the specific handling explained in Section 2 .
We find that that the overall accuracy decreases from 55.1 % to 51.5 % , demonstrating the competence of our approach to model such operations .
This effectiveness is further emphasized when focusing on questions that contain a superlative ( e.g. , " tallest " , " most expensive " ) with a performance difference of 47.3 % with numeric relations and 40.3 % without .
It is worthwhile to call out that the model without special number handling still out -performs the previous SOTA CAMP by more than 5 points ( 45.6 % vs 55.1 % ) .
55.1 % overall ) .
4 Error analysis .
Table 2 shows an example that is consistently handled correctly by the model .
It requires a simple string match ( " nations " ? " nation " ) , and implicit and explicit comparisons .
We performed error analysis on test data over 100 initial ( POS1 ) and 100 follow up questions ( POS > 1 ) to identify the limitations of our approach .
For the initial questions , we find that 26 % are match errors , e.g. , the model does not match " episode " to " Eps # " , or cases where the model has to exclude rows with empty values from the results .
29 % of the errors require a more sophisticated table understanding , e.g. , rows that represent the total of all other rows should often not be included in the answers .
For 15 % of the errors , we think that the reference answer is incorrect and for another 15 % the model prediction is correct but contains duplicates because multiple rows contain the same value .
12 % of the errors are around complex matches such as selecting certain ranks ( " the first two " ) , exclusion or negation .
For the follow up questions , 38 % are caused by complex matches ; 17 % are match errors ; 13 % of the errors are due to incorrect reference answers and 11 % would require advanced table understanding .
Only 8 % of the errors are due to incorrect management of the conversational context .
Section
B of the appendix contains a more detailed analysis and error examples .
Discussion
We present a model for table-centered conversational QA that predicts the answers directly from 4 Fig. 3 of the appendix shows a scatter plot of table size vs. accuracy .
the table .
We show that this model improves SOTA on SQA dataset and particularly handles conversational context effectively .
As future work , we plan to expand our model with pre-trained language representations ( e.g. , BERT ( Devlin et al. , 2018 ) ) in order to improve performance on initial queries and matching of queries to table entries .
To handle larger tables , we will investigate sharding the table row-wise , running the model on all the shards first , and then on the final table which combines all the answer rows .
Table 1 : 1 SQA test results .
? marks contextual models using the previous question or the answer to the previous question .
* marks the models that use the table content .
RA denotes an oracle model that has access to the previous reference answer at test time .
ALL is the average question accuracy , SEQ the sequence accuracy , and POS X , the accuracy of the X'th question in a sequence .
Model ALL SEQ POS1 POS2 POS3 FP * 34.1 7.2 52.6 25.6 25.9 NP * 39.4 10.8 58.9 35.9 24.6 DYNSP 42.0 10.2 70.9 35.8 20.1 FP ? * 33.2 7.7 51.4 22.2 22.3 NP ? * 40.2 11.8 60.0 35.9 25.5 DYNSP ? 44.7 12.8 70.4 41.1 23.6 CAMP ? * 45.6 13.2 70.3 42.6 24.8 OURS * 45.1 13.3 67.2 42.4 26.4 OURS ? * 55.1 28.1 67.2 52.7 46.8 OURS ? * ( RA ) 61.7 28.1 67.2 60.1 57.7
Table size . size
We observe that our model is not sensitive to table size changes , with an average accuracy of 52.4 % for the 10 % largest tables ( vs .
What are all the nations ?
Rank Nation Gold Silver Bronze Total Australia , Italy , Germany , Soviet Union , 1 Australia 2 1 0 3 Switzerland , United States , Great Britain , France 2 Italy 1 1 1 3 Which won gold medals ?
3 4 Germany Soviet Union 1 1 0 0 1 0 2 1 Australia , Italy , Germany , Soviet Union 5 Switzerland 0 2 1 3 Which won more than one ?
Australia 6 7 7 United States Great Britain France 0 0 0 1 0 0 0 1 1 1 1 1
Table 2 : 2 A sequence of questions ( left ) and the corresponding table ( right ) selected from the SQA dataset that is answered correctly by our approach .
This example requires handling conversational context and numerical comparisons .
Whitespace tokenization simplifies the preprocessing but we can expect an off-the-shelf tokenizer to work as good or even better .
