title
Self-Attention : A Better Building Block for Sentiment Analysis Neural Network Classifiers
abstract
Sentiment Analysis has seen much progress in the past two decades .
For the past few years , neural network approaches , primarily RNNs and CNNs , have been the most successful for this task .
Recently , a new category of neural networks , self-attention networks ( SANs ) , have been created which utilizes the attention mechanism as the basic building block .
Self-attention networks have been shown to be effective for sequence modeling tasks , while having no recurrence or convolutions .
In this work we explore the effectiveness of the SANs for sentiment analysis .
We demonstrate that SANs are superior in performance to their RNN and CNN counterparts by comparing their classification accuracy on six datasets as well as their model characteristics such as training speed and memory consumption .
Finally , we explore the effects of various SAN modifications such as multi-head attention as well as two methods of incorporating sequence position information into SANs .
Introduction Sentiment analysis , also know as opinion mining , deals with determining the opinion classification of a piece of text .
Most commonly the classification is whether the writer of a piece of text is expressing a position or negative attitude towards a product or a topic of interest .
Having more than two sentiment classes is called fine- grained sentiment analysis with the extra classes representing intensities of positive / negative sentiment ( e.g. very-positive ) and / or the neutral class .
This field has seen much growth for the past two decades , with many applications and multiple classifiers proposed [ M?ntyl ?
et al. , 2018 ] .
Sentiment analysis has been applied in areas such as social media [ Jansen et al. , 2009 ] , movie reviews [ Pang et al. , 2002 ] , commerce [ Jansen et al. , 2009 ] , and health care [ Greaves et al. , 2013 b ] [ Greaves et al. , 2013a .
In the past few years , neural network approaches have consistently advanced the state - of - the - art technologies for sentiment analysis and other natural language processing ( NLP ) tasks .
For sentiment analysis , the neural network approaches typically use pre-trained word embeddings such as word2vec [ Mikolov et al. , 2013 ] or GloVe [ Pennington et al. , 2014 ] for input , which get processed by the model to create a sentence representation that is finally used for a softmax classification output layer .
The main neural network architectures that have been applied for sentiment analysis are recurrent neural networks ( RNNs ) [ Tai et al. , 2015 ] and convolutional neural networks ( CNNs ) [ Kim , 2014 ] , with RNNs being more popular of the two .
For RNNs , typically gated cell variants such as long short -term memory ( LSTM ) [ Hochreiter and Schmidhuber , 1997 ] , Bi-Directional LSTM ( BiLSTM ) [ Schuster and Paliwal , 1997 ] , or gated recurrent unit ( GRU ) are used .
Most recently , Vaswani et al .
[ Vaswani et al. , 2017 ] introduced the first fully -attentional architecture , called Transformer , which utilizes only the self-attention mechanism and demonstrated its effectiveness on neural machine translation ( NMT ) .
The Transformer model achieved state- ofthe - art performance on multiple machine translation datasets , without having recurrence or convolution components .
Since then , self-attention networks have been successfully applied to a variety of tasks , including : image classification [ Parmar et al. , 2018 ] , generative adversarial networks , automatic speech recognition [ Povey et al. , 2017 ] , text summarization , semantic role labeling [ Strubell et al. , 2018 ] , as well as natural language inference and sentiment analysis [ Shen et al. , 2018 ] .
In this paper we demonstrate that self-attention is a better building block compared to recurrence or convolutions for sentiment analysis classifiers .
We extend the work of [ Barnes et al. , 2017 ] by exploring the behaviour of various self-attention architectures on six different datasets and making direct comparisons to their work .
We set our baselines to be their results for LSTM , BiLSTM , and CNN models , and used the same code for dataset preprocessing , word embedding imports , and batch construction .
Finally , we explore the effectiveness of SAN architecture variations such as different techniques of incorporating positional information into the network , using multi-head attention , and stacking self-attention layers .
Our results suggest that relative position representations is superior to positional encodings , as well as highlight the efficiency of the stacking self-attention layers .
Source code is publicly available 1 .
Background
The attention mechanism was introduced by to improve the RNN encoderdecoder sequence - to-sequence architecture for NMT [ Sutskever et al. , 2014 ] .
Since then , it has been extensively used to improve various RNN and CNN architectures ( [ Cheng et al. , 2016 ] ; [ Kokkinos and Potamianos , 2017 ] ; [ Lu et al. , 2016 ] ) .
The attention mechanism has been an especially popular modification for RNN - based architectures due to its ability to improve the modeling of long range dependencies ( [ Daniluk et al. , 2017 ] ; ) .
Attention Originally described attention as the process of computing a context vector for the next decoder step that contains the most relevant information from all of the encoder hidden states by performing a weighted average on the encoder hidden states .
How much each encoder state contributes to the weighted average is determined by an alignment score between that encoder state and previous hidden state of the decoder .
More generally , we can consider the previous decoder state as the query vector , and the encoder hidden states as key and value vectors .
The output is a weighted average of the value vectors , where the weights are determined by the compatibility function between the query and the keys .
Note that the keys and values can be different sets of vectors [ Vaswani et al. , 2017 ] .
The above can be summarized by the following equations .
Given a query q , values ( v 1 , ... , v n ) , and keys ( k 1 , ... , k n ) we compute output z : z = n j=1 ? j ( v j ) ( 1 ) ? j = exp f ( k j , q ) n i=1 exp f ( k i , q ) ( 2 ) ? j is computed using the softmax function where f ( k i , q ) is the compatibility score between k i and q , For the compatibility function , we will be using using the scaled dot-product function from [ Vaswani et al. , 2017 ] : f ( k , q ) = ( k ) ( q ) T ? d k ( 3 ) where d k is the dimension of the key vectors .
This scaling is done to improve numerical stability as the dimension of keys , values , and queries grows .
Self-Attention Self-attention is the process of applying the attention mechanism outlined above to every position of the source sequence .
This is done by creating three vectors ( query , key , value ) for each sequence position , and then applying the attention mechanism for each position x i , using the x i query vector and key and value vectors for all other positions .
As a result , an input sequence X = ( x 1 , x 2 , ... , x n ) of words is transformed into a sequence Y = (y 1 , y 2 , ... , y n ) where y i incorporates the information of x i as well as how x i relates to all other positions in X .
The ( query , key , value ) vectors can be created by applying learned linear projections [ Vaswani et al. , 2017 ] , or using feed -forward layers .
This computation can be done for the entire source sequence in parallel by grouping the queries , keys , and values in Q , K , V matrices [ Vaswani et al. , 2017 ] . Attention ( Q , K , V ) = softmax ( QK T ? d k ) V ( 4 ) Furthermore , instead of performing selfattention once for ( Q , K , V ) of dimension d model , [ Vaswani et al. , 2017 ] proposed multi-head attention , which performs attention h times on projected ( Q , K , V ) matrices of dimension d model /h .
For each head , the ( Q , K , V ) matrices are uniquely projected to dimension d model /h and self-attetnion is performed to yield an output of dimension d model /h .
The outputs of each head are then concatenated , and once again a linear projection layer is applied , resulting in an output of same dimensionality as performing self-attention once on the original ( Q , K , V ) matrices .
This process is described by the following formulas : MultiHead ( Q , K , V ) = Concat ( head 1 , ... , head h ) W O ( 5 ) where head i = Attention ( QW Q i , KW K i , V W V i ) ( 6 ) Where the projections are parameter matrices W Q i ?
R d model ?d k , W K i ?
R d model ?d k , W V i ?
R d model ? dv and W O ? R hdv?d model .
Position Information Techniques
The attention mechanism is completely invariant to sequence ordering , thus self-attention networks need to incorporate positional information .
Three main techniques have been proposed to solve this problem : adding sinusoidal positional encodings or learned positional encoding to input embeddings , or using relative positional representations in the self-attention mechanism .
Sinusoidal Position Encoding
This method was proposed by [ Vaswani et al. , 2017 ] to be used for the Transformer model .
Here , positional encoding ( P E ) vectors are created using sine and cosine functions of difference frequencies and then are added to the input embeddings .
Thus , the input embeddings and positional encodings must have the same dimensionality of d model .
The following sine and cosine functions are used : P E ( pos , 2i ) = sin( pos/10000 2i / d model ) P E ( pos , 2 i+ 1 ) = cos( pos/10000 2i / d model ) where pos is the sentence position and i is the dimension .
Using this approach , sentences longer than those seen during training can still have positional information added .
We will be referring to this method as P E .
Learned Position Encoding
In a similar method , learned vectors of the same dimensionality , that are also unique to each position can be added to the input embeddings instead of sinusoidal position encodings [ Gehring et al. , 2017 ] .
There are two downsides to this approach .
First , this method cannot handle sentences that are longer than the ones in the training set as no vectors are trained for those positions .
Second , the further position will likely not get trained as well if the training dataset has more short sentences than longer ones .
Vaswani et al . [ 2017 ] also reported that these perform identically to the positional encoding approach .
Relative Position Representations Relative Position Representations ( RP R ) was introduced by [ Shaw et al. , 2018 ] as a replacement of positional encodings for the Transformer .
Using this approach , the Transformer was able to perform even better for NMT .
Out of the three discussed , we have found this approach to work best and we will be referring to this method as RP R throughout the paper .
For this method , the self-attention mechanism is modified to explicitly learn the relative positional information between every two sequence positions .
As a result , the input sequence is modeled as a labeled , directed , fully - connected graph , where the labels represent positional information .
A tunable parameter k is also introduced that limits the maximum distance considered between two sequence positions .
[ Shaw et al. , 2018 ] hypothesized that this will allow the model to generalize to longer sequences at test time .
Proposed Architectures
In this work we propose a simple self-attention ( SSAN ) model and test it in 1 as well as 2 layer stacked configurations .
We designed the SSAN architecture to not have any extra components in order to compare specifically the self-attention component to the recurrence and convolution components of LSTM and CNN models .
Our goal is to test the effectiveness of the main building blocks .
We compare directly the results of two proposed architectures , 1 - Layer -SSAN and 2 - Layer - SSAN , to the LSTM , BiLSTM , and CNN architectures from [ Barnes et al. , 2017 ] . SSAN performs self-attention only once , which is identical to 1 - head multi-head attention .
SSAN Figure 1 : SSAN Model Architecture takes in input word embeddings and applies 3 feedforward layers to obtain Q , K , V representations on which self-attention is performed .
The output of the self-attention layer is passed through another feed -forward layer .
This process is done twice for 2 - Layer - SSAN , using the output of first layer as input for the second .
The output of the last self-attention layer is averaged and a feed-forward layer is then applied to create a sentence representation vector of fixed dimension d model .
Finally , the sentence representation vector is passed through an output softmax layer that has an output dimension of d classes .
Dropout [ Srivastava et al. , 2014 ] is applied on input word embeddings , output of self-attention layers , on the sentence representation vector .
The architecture is visualized in Figure 1 . All feed -forward layers use ReLU [ Nair and Hinton , 2010 ] activation functions .
For relative positional representation , we set the parameter k=10 , which is the maximum relative position considered for each input sequence position .
Finally , we also show results for other , more complex , self-attention architectures that are based on the Transformer .
We take a 2 layer Transformer encoder as described by [ Vaswani et al. , 2017 ] , then just like for SSAN , average the output of the second layer to create a sentence representation and apply a feed-forward layer followed by an output softmax layer .
Dropout is applied as described in [ Vaswani et al. , 2017 ] as well as on the sentence representation vector .
Experiments
To reduce implementation deviations from previous work , we use the codebase from [ Barnes et al. , 2017 ] and only replace the model and training process .
We re-use the code for batch preprocessing and batch construction for all datasets , accuracy evaluation , as well as use the same word embeddings 2 . All neural network models use crossentropy for the training loss .
All experiments and benchmarks were run using a single GTX 1080 Ti with an i7 5820 k @ 3.3 Ghz and 32 Gb of RAM .
For model implementations : LSTM , BiLSTM , and CNN baselines are implemented in Keras 2.0.8 [ Chollet et al. , 2015 ] with Tensorflow 1.7 backend using cuDNN 5.1.5 and CUDA 9.1 .
All self-attention models are implemented in Tensorflow 1.7 and use the same CUDA libraries .
Datasets
In order to determine if certain neural network building blocks are superior , we test on six datasets from [ Barnes et al. , 2017 ] with different properties .
The summary for dataset properties is in Table 1 . The Stanford Sentiment Treebank ( SST - fine ) [ Socher et al. , 2013 ]
The SenTube datasets [ Uryupina et al. , 2014 ] consist of YouTube comments with two sentiment classes : positive and negative .
These datasets contain the longest average sentence length as well as the longest maximum sentence length of all the datasets .
The SemEval Twitter dataset ( SemEval ) [ Nakov et al. , 2013 ] consists of tweets with three classes : positive , negative , and neutral .
Embeddings
We use the exact same word embeddings as [ Barnes et al. , 2017 ] .
They trained the 50 , 100 , 200 , and 600 - dimensional word embeddings using the word2vec algorithm described in [ Mikolov et al. , 2013 ] on a 2016 Wikipedia dump .
In order to compare to previous work , they also used the publicly available Google 300 - dimensional word2vec embeddings , which are trained on a part of Google News dataset 3 . For all models , out - of- vocabulary words are initialized randomly from the uniform distribution on the interval [ - 0.25 , 0.25 ] .
3 https://code.google.com/archive/p/ word2vec /
Baselines
We take 5 classifiers from [ Barnes et al. , 2017 ] and use their published results as baselines .
Two of the methods are based on logistic regression , Bow and Ave , and 3 are neural network based , LSTM , BiLSTM , and CNN .
The ( Bow ) baseline is a L2 - regularized logistic regression trained on bag-of-words representation .
Each word is represented by a one- hot vectors of size n = | V | , where | V | is the vocabulary size .
The ( Ave ) baseline is also a L2 - regularized logistic regression classifier except trained on the average of the 300 - dimension word embeddings for each sentence .
The LSTM baseline , input word embeddings are passed into an LSTM layer .
Then a 50 - dimensional feed -forward layer with ReLU activations is applied , followed by a softmax layer that produces that model classification outputs .
Dropout [ Srivastava et al. , 2014 ] is applied to the input word embeddings for regularization .
The BiLSTM baseline is the same as LSTM , except that a second LSTM layer is used to process the input word embeddings in the reverse order .
The outputs of the two LSTM layers are concatenated and passed a feed-forward layer , following by the output softmax layer .
Dropout is applied identically as in LSTM .
This modification improves the networks ability to capture long-range dependencies .
The final baseline is a simple CNN network .
The input sequence of n embeddings is reshaped to an n?R dimensional matrix M , where R is the dimensionality of the embeddings .
Convolutions with filter size of [ 2 , 3 , 4 ] are applied to M , following by a pooling layer of length 2 .
As for LSTM networks , a Table 2 : Modified Table 3 from [ Barnes et al. , 2017 ] .
Test accuracy averages and standard deviations ( in brackets ) of 5 runs .
The baseline results are taken from [ Barnes et al. , 2017 ] ; the self-attention models results are ours .
Best model for each dataset is given in bold . feed -forward layer is applied followed by an output softmax layer .
Here , dropout is applied to input embeddings as well as after the convolution layers .
The LSTM , BiLSTM , and CNN baselines are trained using ADAM [ Kingma and Ba , 2014 ] with cross-entropy loss and mini-batches of size 32 .
Hidden layer dimension , dropout amount , and the number of training epochs are tuned on the validation set for each ( model , input embedding , dataset ) combination .
Self-Attention Architectures
We use 1 - Layer SSAN + RPR and 2 - Layer SSAN + RPR to compare the self-attention mechanism to the recurrence and convolution mechanisms in LSTM , BiLSTM , and CNN models .
We compare these models using all word embeddings sizes .
Next , we explore the performance of a modified Transformer Encoder described in 3 .
We do this to determine if a more complex architecture that utilized multi-head attention is more beneficial .
Finally , we compare the performance of using positional encodings ( + PE ) representations ( + RPR ) for the Transformer Encoder and 1 - Layer - SSAN architectures .
We also test 1 - Layer SSAN without using any positional information techniques .
For the self-attention networks , we simplify the training process to only tune one parameter and apply the same process to all models .
Only the learning rate is tuned for every ( model , input embedding ) pair .
We fix the number of batches to train for to 100,000 and pick the model with highest validation accuracy .
Each batch is constructed by randomly sampling the training set .
Model dimensionality d model is fixed to being the same as the input word embeddings .
Learning rate is tuned based on the size of d model .
For d model dimensions [ 50 , 100 , 200 , 300 , 600 ] we use learning rates of [ 0.15 , 0.125 , 0.1 , 0.1 , 0.05 ] respectively , because the larger d model models tend to over -fit faster .
Dropout of 0.7 is applied to all models , and the ADADELTA [ Zeiler , 2012 ] optimizer is used with cross-entropy loss .
Analysis
Table 2 contains the summary of all the experimental results .
For all neural network models we report mean test accuracy of five runs as well as the standard deviations .
Macro- Avg results are the average accuracy of a model across all datasets .
We focus our discussion on the Macro- Avg column as it demonstrates the models general performance for sentiment analysis .
Our results show general better performance for self-attention networks in comparison to LSTM , BiLSTM and CNN models .
Using the same word embedding , all of the self-attention models receive higher Macro - Avg accuracy than all baseline models .
1 - Layer-SSAN +RPR models generally perform the best for all ( input embeddings , dataset ) combinations , and getting top scores for five out of six datasets .
Transformer Encoder +RPR also performs comparatively well across all datasets , and achieves top accuracy for the OpeNER dataset .
Using 2 - Layer-SSAN +RPR does not yield better performance results compared to 1 - Layer - SSAN + RPR .
We believe that one self-attention layer is sufficient as the datasets that we have tested on were relatively small .
This is reinforced by the results we see from Transformer Encoder + RPR since it achieves similar accuracy as 2 - Layer-SSAN + RPR and 1 - Layer-SSAN + RPR while having greater architectural complexity and more trainable parameters , see Table 3 . Using relative positional representations for 1 - Layer-SSAN + RPR increases the Macro- Avg accuracy by 2.8 % compared to using positional encodings for 1 - Layer - SSAN + PE , and by 0.9 % compared to using no positional information at all ( 1 - Layer - SSAN ) .
Interestingly enough , we observe that using no positional information performs better than using positional encodings .
This could be attributed once again to small dataset size , as [ Vaswani et al. , 2017 ] successfully used positional encodings for larger MT datasets .
Another observation is that SenTube dataset trials achieve a low accuracy despite having binary classes .
This is unexpected as generally with a low number of classes it is easier to train on the dataset and achieve higher accuracy .
We suspect that this is because SenTube contains longer sentences and very low word embedding coverage .
Despite this , SSANs perform relatively well on the SenTube -A dataset , which suggests that they are superior at capturing long- range dependencies compared to other models .
Smaller d model SSAN models perform worse for lower dimension input embeddings on SST - fine , SST - binary and OpeNER datasets while still performing well on SenTube and SemEval .
This is caused by the limitations of our training process where we forced the network d model to be same size as the input word embeddings and use the same learning rate for all datasets .
We found that working with smaller dimensions of d model the learning rate needed to be tuned individually for some datasets .
For example , using a learning of 0.15 for 50D models would work well for SenTube and SemEval , but would under-fit for SST - fine , SSTbinary and OpeNER datasets .
We decided to not modify the training process for the smaller input embeddings in order to keep our training process simplified .
Model Characteristics
Here we compare training and test efficiency , memory consumption and number of trainable parameters for every model .
For all models , we use the SST - fine dataset , hidden dimension size of 300 , Google 300D embeddings , batch sizes of 32 for both training and inference , and the ADAM optimizer [ Kingma and Ba , 2014 ] .
The Training Time test is the average time it takes every model to train on 10 epochs of the SST - fine train set ( 2670 batches of size 32 ) .
The Inference
Time test is the average time it takes a model to produce predictions for the validation set 10 times ( 344 batches of size 32 ) .
Table 3 contains the summary of model characteristics .
The GPU VRAM usage is the amount of GPU video memory that is used during training .
CNN has the lowest number of parameters but consumes the most GPU memory .
It also has the shortest training and inference time , which we attributed to the low number of parameters .
Using relative position representations compared to positional encoding for 1 - Layer - SSAN increases the number of trainable parameters by only 2.7 % , training time by 11.2 % , and inference time by 4.7 % .
These findings are similar to what [ Shaw et al. , 2018 ] reported .
BiLSTM has double the number of parameters as well as near double training and inference times compared to LSTM .
This is reasonable due to the nature of the architecture being two LSTM layers .
Much like BiLSTM , going from 1 - Layer -SSAN to 2 - Layer -SSAN doubles the number of trainable parameters .
However , the training and inference times only increase by 20.1 % and 9.4 % respectively .
This demonstrates the efficiency of the selfattention mechanism due to it utilizing only matrix multiply operations , for which GPUs are highlyoptimized .
We also observe that self-attention models are faster to train than LSTM by about 3.4 times , and 5.9 times for BiLSTM .
However , inference times are slower than LSTM by 15.5 % and faster than BiLSTM by 41 % .
Conclusion
In this paper we focused on demonstrating that selfattention networks achieve better accuracy than previous state - of - the - art techniques on six datasets .
In our experiments , multiple SSAN networks performed better than CNN and RNN architectures ; Self-attention architecture resulted in higher accuracy than LSTMs while having 35 % fewer parameters and shorter training time by a factor of 3.5 .
Additionally , we showed that SSANs achieved higher accuracy on the SenTube datasets , which suggests they are also better at capturing long-term dependencies than RNNs and CNNs .
Finally , we reported that using relative positional representation is superior to both using positional encodings , as well as not incorporating any positional information at all .
Using relative positional representations for self-attention architectures resulted in higher accuracy with negligible impact on model training and inference efficiency .
For future work , we plan to extend the SSAN networks proposed to achieve state - of - the - art results on the complete SST dataset .
We are also interested to see the behaviour of the models explored in this work on much larger datasets , we hypothesize that stacked multi-head self-attention architectures will perform significantly better than RNN and CNN counterparts , all while remaining more efficient at training and inference .
