title
Recursive Autoencoders for ITG - based Translation
abstract
While inversion transduction grammar ( ITG ) is well suited for modeling ordering shifts between languages , how to make applying the two reordering rules ( i.e. , straight and inverted ) dependent on actual blocks being merged remains a challenge .
Unlike previous work that only uses boundary words , we propose to use recursive autoencoders to make full use of the entire merging blocks alternatively .
The recursive autoencoders are capable of generating vector space representations for variable -sized phrases , which enable predicting orders to exploit syntactic and semantic information from a neural language modeling 's perspective .
Experiments on the NIST 2008 dataset show that our system significantly improves over the MaxEnt classifier by 1.07 BLEU points .
Introduction Phrase - based models ( Koehn et al. , 2003 ; Och and Ney , 2004 ) have been widely used in practical machine translation ( MT ) systems due to their effectiveness , simplicity , and applicability .
First , as sequences of consecutive words , phrases are capable of memorizing local word selection and reordering , making them an effective mechanism for translating idioms or translations with word insertions or omissions .
Moreover , n-gram language models can be seamlessly integrated into phrase - based decoders since partial translations grow left to right in decoding .
Finally , phrase - based systems can be applicable to most domains and languages , espe-cially for resource -scarce languages without highaccuracy parsers .
However , as phrase - based decoding casts translation as a string concatenation problem and permits arbitrary permutations , it proves to be NP -complete ( Knight , 1999 ) .
Therefore , phrase reordering modeling has attracted intensive attention in the past decade ( e.g. , Tillman , 2004 ; Zens et al. , 2004 ; Al - Onaizan and Papineni , 2006 ; Xiong et al. , 2006 ; Koehn et al. , 2007 ; Galley and Manning , 2008 ; Feng et al. , 2010 ; Green et al. , 2010 ; Bisazza and Federico , 2012 ; Cherry , 2013 ) .
Among them , reordering models based on inversion transduction grammar ( ITG ) ( Wu , 1997 ) are one of the important ongoing research directions .
As a formalism for bilingual modeling of sentence pairs , ITG is particularly well suited to predicting ordering shifts between languages .
As a result , a number of authors have incorporated ITG into leftto-right decoding to constrain the reordering space and reported significant improvements ( e.g. , Zens et al. , 2004 ; Feng et al. , 2010 ) .
Along another line , Xiong et al . ( 2006 ) propose a maximum entropy ( MaxEnt ) reordering model based on ITG .
They use the CKY algorithm to recursively merge two blocks ( i.e. , a pair of source and target strings ) into larger blocks , either in a straight or an inverted order .
Unlike lexicalized reordering models ( Tillman , 2004 ; Koehn et al. , 2007 ; Galley and Manning , 2008 ) that are defined on individual bilingual phrases , the Max-Ent ITG reordering model is a two -category classifier ( i.e. , straight or inverted ) for two arbitrary bilingual phrases of which the source phrases are adjacent .
This potentially alleviates the data sparseness problem since there are usually a large number of reordering training examples available ( Xiong et al. , 2006 ) .
As a result , the MaxEnt ITG model and its extensions ( Xiong et al. , 2008 ; Xiong et al. , 2010 ) have achieved competing performance as compared with state - of - the - art phrase - based systems .
Despite these successful efforts , the ITG reordering classifiers still face a major challenge : how to extract features from training examples ( i.e. , a pair of bilingual strings ) .
It is hard to decide which words are representative for predicting reordering , either manually or automatically , especially for long sentences .
As a result , Xiong et al . ( 2006 ) only use boundary words ( i.e. , the first and the last words in a string ) to predict the ordering .
What if we look inside ?
Is it possible to avoid manual feature engineering and learn semantic representations from the data ?
Fortunately , the rapid development of intersecting deep learning with natural language processing ( Bengio et al. , 2003 ; Collobert and Weston , 2008 ; Collobert et al. , 2011 ; Glorot et al. , 2011 ; Bordes et al. , 2011 ; Socher et al. , 2011a ; Socher et al. , 2011 b ; Socher et al. , 2011c ; Socher et al. , 2012 ; Bordes et al. , 2012 ; Huang et al. , 2012 ; Socher et al. , 2013 ; Hermann and Blunsom , 2013 ) brings hope for alleviating this problem .
In these efforts , natural language words are represented as real-valued vectors , which can be naturally fed to neural networks as input .
More importantly , it is possible to learn vector space representations for multi-word phrases using recursive autoencoders ( Socher et al. , 2011 c ) , which opens the door to leveraging semantic representations of phrases in reordering models from a neural language modeling point of view .
In this work , we propose an ITG reordering classifier based on recursive autoencoders .
The neural network consists of four autoencoders ( i.e. , the first source phrase , the first target phrase , the second source phrase , and the second target phrase ) and a softmax layer .
The recursive autoencoders , which are trained on reordering examples extracted from word-aligned bilingual corpus , are capable of producing vector space representations for arbitrary multi-word strings in decoding .
Therefore , our model takes the whole phrases rather than only boundary words into consideration when predicting phrase permutations .
Experiments on the NIST 2008 dataset show that our system significantly improves over the MaxEnt classifier by 1.07 in terms of case-insensitive BLEU score .
2 Recursive Autoencoders for ITG - based Translation
Inversion Transduction Grammar Inversion transduction grammar ( ITG ) ( Wu , 1997 ) is a formalism for synchronous parsing of bilingual sentence pairs .
Xiong et al. ( 2006 ) apply bracketing transduction grammar ( BTG ) , which is a simplified version of ITG , to phrase - based translation using the following production rules : X ? [ X 1 , X 2 ] ( 1 ) X ? X 1 , X 2 ( 2 ) X ? f /e ( 3 ) where X is a block that consists of a pair of source and target strings , f is a source phrase , and e is a target phrase .
X 1 and X 2 are two neighboring blocks of which the two source phrases are adjacent .
While rule ( 1 ) merges two target phrases in a straight order , rule ( 2 ) merges in an inverted order .
Besides these two reordering rules , rule ( 3 ) is a lexical rule that translates a source phrase f into a target phrase e .
This is exactly a bilingual phrase used in conventional phrase - based systems .
An ITG derivation , which consists of a sequence of production rules , explains how a sentence pair is generated simultaneously .
Figure 1 shows an ITG derivation for a Chinese sentence and its English translation .
We distinguish between two types of blocks : 1 . atomic blocks : blocks generated by applying lexical rules , 2 . composed blocks : blocks generated by applying reordering rules .
In Figure 1 , the sentence pair is segmented into five atomic blocks : X 0,3,0,3 : wo you yi ge ?
I have a X 3,5,5,6 : cong mei you ?
never X 5,8,6,8 : jian guo de ? seen before X 8,10 , 3,5 : nv xing peng you ?
female friend X 10,11, 8,9 : . ? . Figure 1 : An ITG derivation for a Chinese sentence and its translation .
We use X i , j, k , l = f j i , e l k to represent a block .
Our neural ITG reordering model first assigns vector space representations to single words and then produces vectors for phrases using recursive autoencoders , which form atomic blocks .
The atomic blocks are recursively merged into composed blocks , the vector space representations of which are produced by recursive autoencoders simultaneously .
The neural classifier makes decisions at each node using the vectors of all its descendants .
where X 3,5,5,6 indicates that the block consists of a source phrase spanning from position 3 to position 5 ( i.e. , " cong mei you " ) and a target phrase spanning from position 5 to position 6 ( i.e. , " never " ) .
More formally , a block X i , j , k , l = f j i , e l k is a pair of a source phrase f j i = f i + 1 . . . f j and a target phrase e l k = e k+1 . . . e l .
Obviously , these atomic blocks are generated by lexical rules .
Two blocks of which the source phrases are adjacent can be merged into a larger one in two ways : concatenating the target phrases in a straight order using rule ( 1 ) or in an inverted order using rule ( 2 ) .
For example , atomic blocks X 3,5,5,6 and X 5,8,6,8 are merged into a composed block X 3,8,5,8 in a straight order , which is further merged with an atomic block X 8,10 , 3, 5 into another composed block X 3,10 , 3, 8 in an inverted order .
This process recursively proceeds until the entire sentence pair is generated .
The major challenge of applying ITG to machine translation is to decide when to merge two blocks in a straight order and when in an inverted order .
Therefore , the ITG reordering model can be seen as a two -category classifier P ( o| X 1 , X 2 ) , where o ?
{ straight , inverted } .
A naive way is to assign fixed probabilities to two reordering rules , which is referred to as flat model by Xiong et al . ( 2006 ) : P ( o|X 1 , X 2 ) = p o = straight 1 ? p o = inverted ( 4 )
The drawback of the flat model is ignoring the actual blocks being merged .
Intuitively , different blocks should have different preferences between the two orders .
To alleviate this problem , Xiong et al . ( 2006 ) propose a maximum entropy ( MaxEnt ) classifier : P ( o|X 1 , X 2 ) = exp (? ? h( o , X 1 , X 2 ) ) o exp (? ? h( o , X 1 , X 2 ) ) ( 5 ) where h( ? ) is a vector of features defined on the blocks and the order , ? is a vector of feature weights .
While MaxEnt is a flexible and powerful framework for including arbitrary features , feature engineering becomes a major challenge for the MaxEnt classifier .
Xiong et al. ( 2006 ) find that boundary words ( i.e. , the first and the last words in a string ) are informative for predicting reordering .
Actually , Figure 2 : A recursive autoencoder for multi-word strings .
The example is adapted from ( Socher et al. , 2011 c ) .
Blue and grey nodes are original and reconstructed ones , respectively .
it is hard to decide which internal words in a long composed blocks are representative and informative .
Therefore , they only use boundary words as the main features .
However , it seems not enough to just consider boundary words and ignore all internal words when making order predictions , especially for long sentences .
1 Indeed , Xiong et al. ( 2008 ) find that the MaxEnt classifier with boundary words as features is prone to make wrong predictions for long composed blocks .
As a result , they have to impose a hard constraint to always prefer merging long composed blocks in a monotonic way .
Therefore , it is important to consider more than boundary words to make more accurate reordering predictions .
We need a new mechanism to achieve this goal .
Recursive Autoencoders
Vector Space Representations for Words
In neural networks , a natural language word is represented as a real-valued vector ( Bengio et al. , 2003 ; Collobert and Weston , 2008 ) .
For example , we can use [ 0.1 0.8 0.4 ]
T to represent " female " and [ 0.7 0.1 0.5 ]
T to represent " friend " .
Such vector space representations enable natural language words to be fed to neural networks as input .
Formally , we denote each word as a vector x ?
R n .
These word vectors are then stacked into a word embedding matrix L ? R n?|V | , where | V | is the vocabulary size .
Given a sentence that is an ordered list of m words , each word has an associated vocabulary index k into the word embedding matrix L that we use to retrieve the word 's vector space representation .
This look - up operation can be seen as a simple projection layer : x i = Lb k ?
R n ( 6 ) where b k is a binary vector which is zero in all positions except for the kth index .
In Figure 1 , we assume n = 3 for simplicity and can retrieve vectors for Chinese and English words from two embedding matrices , respectively .
Vector Space Representations for Multi-Word Strings
To apply neural networks to ITG - based translation , it is important to generate vector space representations for atomic and composed blocks .
For example , since the vector of " female " is [ 0.1 0.8 0.4 ]
T and the vector of " friend " is [ 0.7 0.1 0.5 ]
T , what is the vector of the phrase " female friend " ?
If we denote " female friend " as p ( i.e. , parent ) , " female " as c 1 ( i.e. , the first child ) , and " friend " as c 2 ( i.e. , the second child ) , this can be done by applying a function f ( 1 ) : p = f ( 1 ) ( W ( 1 ) [ c 1 ; c 2 ] + b ( 1 ) ) ( 7 ) where [ c 1 ; c 2 ] ?
R 2n?1 is the concatenation of c 1 and c 2 , W ( 1 ) ?
R n?2n is a parameter matrix , b ( 1 ) ?
R n?1 is a bias term , and f ( 1 ) is an element- wise activation function such as tanh ( ? ) , which is used in our experiments .
Note that the resulting vector for the parent is also an n-dimensional vector , e.g , [ 0.6 0.9 0.2 ]
T .
The same neural network can be recursively applied to two strings until the vector of the entire sentence is generated .
As ITG derivation builds a binary parse tree , the neural network can be naturally integrated into CKY parsing .
To assess how well the learned vector p represents its children , we can reconstruct the children in a reconstruction layer : [ c 1 ; c 2 ] = f ( 2 ) ( W ( 2 ) p + b ( 2 ) ) ( 8 ) where c 1 and c 2 are the reconstructed children , W ( 2 ) is a parameter matrix for reconstruction , b ( 2 ) is a bias term for reconstruction , and f ( 2 ) is an element- wise activation function , which is also set as tanh ( ? ) in our experiments .
Similarly , the same reconstruction neural network can be applied to each node in an ITG parse .
These neural networks are called recursive autoencoders ( Socher et al. , 2011 c ) .
Figure 2 illustrates an application of a recursive autoencoder to a binary tree .
The blue and grey nodes are the original and reconstructed nodes , respectively .
The autoencoder is re-used at each node of the tree .
The binary tree is composed of a set of triplets in the form of ( p ? c 1 c 2 ) , where p is a parent vector and c 1 and c 2 are children vectors of p .
Each child can be either an input word vector or a multi-word vector .
Therefore , the tree in Figure 2 can be represented as three triplets : ( y 1 ? x 1 x 2 ) , (y 2 ? y 1 x 3 ) , and ( y 3 ? y 2 x 4 ) .
In Figure 1 , we use recursive autoencoders to generate vector space representations for Chinese and English phrases , which form the atomic blocks for further block merging .
A Neural ITG Reordering Model
Once the vectors for blocks are generated , it is straightforward to introduce a neural ITG reordering model .
As shown in Figure 3 , the neural network consists of an input layer and a softmax layer .
The input layer is composed of the vectors of the first source phrase , the first target phrase , the second source phrase , and the second target phrase .
Note that all phrases in the same language use the the same recursive autoencoder .
The softmax layer outputs the probabilities of the two merging orders : P ( o|X 1 , X 2 ) = exp ( g ( o , X 1 , X 2 ) ) o exp ( g ( o , X 1 , X 2 ) ) ( 9 ) g( o , X 1 , X 2 ) = f ( W o c( X 1 , X 2 ) + b o ) ( 10 ) where o ?
{ straight , inverted} , W o ?
R 1?4n is a parameter matrix , b o ?
R is a bias term , and c( X 1 , X 2 ) ? R 4n?1 is the concatenation of the vectors of the four phrases .
Training
There are three sets of parameters in our recursive autoencoders : 1 . ? L : word embedding matrix L for both source and target languages ( Section 2.2.1 ) ; 2 . ? rec : recursive autoencoder parameter matrices W ( 1 ) , W ( 2 ) and bias terms b ( 1 ) , b ( 2 ) for both source and target languages ( Section 2.2.2 ) ;
3 . ? reo : neural ITG reordering model parameter matrix W o and bias term b o ( Section 2.2.3 ) .
All these parameters are learned automatically from the training data .
For clarity , we will use ? to denote all these parameters in the rest of the paper .
For training word embedding matrix , there are two settings commonly used .
In the first setting , the word embedding matrix is initialized randomly .
This works well in a supervised scenario , in which a neural network updates the matrix in order to optimize some task -specific objectives ( Collobert et al. , 2011 ; Socher et al. , 2011 c ) .
In the second setting , the word embedding matrix is pre-trained using an unsupervised neural language model ( Bengio et al. , 2003 ; Collobert and Weston , 2008 ) with huge amount of unlabeled data .
In this work , we prefer to the first setting because the word embedding matrices can be trained to minimize errors with respect to reordering modeling .
There are two kinds of errors involved 1 . reconstruction error : how well the learned vector space representations represent the corresponding strings ?
2 . reordering error : how well the classifier predicts the merging order ?
As described in Section 2.2.2 , the input vector c 1 and c 2 of a recursive autoencoder can be reconstructed using Eq. 8 as c 1 and c 2 .
We use Euclidean distance between the input and the reconstructed vectors to measure the reconstruction error : E rec ( [ c 1 ; c 2 ] ; ? ) = 1 2 [ c 1 ; c 2 ] ? [ c 1 ; c 2 ] 2 . ( 11 ) Given a sentence , there are exponentially many ways to obtain its vector space representation .
Note that each way corresponds to a binary tree like Figure 2 .
To find a binary tree with minimal reconstruction error , we follow Socher et al . ( 2011 c ) to use a greedy algorithm .
Taking Figure 2 as an example , the greedy algorithm begins with computing the reconstruction error E rec ( ? ) for each pair of consecutive vectors , i.e. , E rec ( [ x 1 ; x 2 ] ; ? ) , E rec ( [ x 2 ; x 3 ] ; ? ) and E rec ( [ x 3 ; x 4 ] ; ? ) .
Suppose E rec ( [ x 1 ; x 2 ] ; ? ) is the smallest , the algorithm will replace x 1 and x 2 with their vector representation y 1 produced by the recursive autoencoder .
Then , the algorithm evaluates E rec ( [ y 1 ; x 3 ] ; ? ) and E rec ( [ x 3 ; x 4 ] ; ? ) and repeats the above replacing steps until only one vector remains .
Socher et al. ( 2011 c ) find that the greedy algorithm runs fast without significant loss in performance as compared with CKY - style algorithms .
Given a training example set S = {t i = ( o i , X 1 i , X 2 i ) } , the average reconstruction error on the source side on the training set is defined as E rec , s ( S ; ? ) = 1 N s i p?T ? R ( t i , s ) E rec ( [ p.c 1 , p.c 2 ] ; ? ) ( 12 ) where T ? R ( t i , s ) denotes all the intermediate nodes on the source side in binary trees , N s is the number of these intermediate nodes , and p.c k is the kth child vector of p .
The average reconstruction error on the target side , denoted by E rec , t ( S ; ? ) , can be computed in a similar way .
Therefore , the reconstruction error is defined as E rec ( S ; ? ) = E rec , s ( S ; ? ) + E rec , t ( S ; ? ) . ( 13 ) Given a training example t i = ( o i , X 1 i , X 2 i ) , we assume the probability distribution d t i for its label is [ 1 , 0 ] when o i = straight , and [ 0 , 1 ] when o i = inverted .
Then the cross-entropy error is E c ( t i ; ? ) = ?
o d t i ( o ) log P ? ( o |X 1 , X 2 ) ( 14 ) where o ?
{ straight , inverted} .
As a result , the reordering error is defined as E reo ( S ; ? ) = 1 | S | i E c ( t i ; ? ) . ( 15 )
Therefore , the joint training objective function is J = ?E rec ( S ; ? ) + ( 1 ? ?) E reo ( S ; ? ) + R ( ? ) ( 16 ) where ? is a parameter used to balance the preference between reconstruction error and reordering error , R ( ? ) is the regularizer and defined as 2 R ( ? ) = ? L 2 ? L 2 + ? rec 2 ? rec 2 + ? reo 2 ? reo 2 . ( 17 ) As Socher et al. ( 2011 c ) stated , a naive way for lowering the reconstruction error is to make the magnitude of the hidden layer very small , which is not desirable .
In order to prevent such behavior , we normalize all the output vectors of the hidden layers to have length 1 in the same way as ( Socher et al. , 2011 c ) .
Namely we set p = p | | p| | after computing p as in Eq. 7 , and c 1 = c 1 ||c 1 || , c 2 = c 2 ||c 2 || in Eq. 8 . Following Socher et al. ( 2011 c ) , we use L-BFGS to estimate the parameters with respect to the joint training objective .
Given a set of parameters , we construct binary trees for all the phrases using the greedy algorithm .
The derivatives for these fixed binary trees can be computed via backpropagation through structures ( Goller and Kuchler , 1996 ) .
Experiments 4.1 Data Preparation
We evaluated our system on Chinese-English translation .
The training corpus contains 1.23 M sentence pairs with 32.1 M Chinese words and 35.4 M English words .
We used SRILM ( Stolcke , 2002 ) to train a 4 - gram language model on the Xinhua portion of the GIGAWORD corpus , which contains 398.6 M words .
We used the NIST 2006 MT Chinese-English dataset as the development set and NIST 2008 dataset as the test set .
The evaluation metric is case-insensitive BLEU .
Because of the expensive computational cost for training our neural ITG reordering model , only the reordering examples extracted from about 1/5 of the entire parallel training corpus were used to train our neural ITG reordering model .
For the neural ITG reordering model , we set the dimension of the word embedding vectors to 25 empirically , which is a trade - off between computational cost and expressive power .
We use the early stopping principle to determine when to stop L-BFGS .
The hyper-parameters ? , ? L , ? rec and ? reo are optimized by random search ( Bergstra and Bengio , 2012 ) .
As preliminary experiments show that classification accuracy has a high correlation with BLEU score , we optimize these hyper-parameters with respect to classification accuracy instead of BLEU to reduce computational cost .
We randomly select 400,000 reordering examples as training set , 500 as development set , and another 500 as test set .
The numbers of straight and inverted reordering examples in the development / test set are set to be equal to avoid biases .
We draw ? uniformly from 0. to 0.3 , and ?
L , ? rec , ? reo exponentially from 10 ?8 to 10 ?2 .
We use the following hyper-parameters in our experiments : ? = 0.11764 , ? L = 7.59 ? 10 ?5 , ? rec = 1.30 ? 10 ?5 and ? reo = 3.80 ? 10 ?4 . 3
The baseline system is a re-implementation of ( Xiong et al. , 2006 ) .
Our system is different from the baseline by replacing the MaxEnt reordering model with a neural model .
Both the systems have the same pruning settings : the threshold pruning parameter is set to 0.5 and the histogram pruning parameter to 40 .
For minimum-error-rate training , both systems generate 200 - best lists .
MT Evaluation
Table 1 shows the case- insensitive BLEU - 4 scores of the baseline system and our system on the development and test sets .
Our system outperforms the baseline system by 1.21 BLEU points on the development set and 1.07 on the test set .
Both the differences are statistically significant at p = 0.01 level ( Riezler and Maxwell , 2005 ) .
Table 2 shows the number of sentences that our system has a higher ( > ) , equal ( = ) or lower ( <) BLEU score on the NIST 2008 dataset .
We find that our system is superior to the baseline system for long 3
The choice of ? is very important for achieving high BLEU scores .
We tried a number of intervals and found that the classification accuracy is most stable in the interval [ 0.100,0.125 ] .
sentences .
Figure 4 compares classification accuracies of the neural and MaxEnt classifiers .
" Length " denotes the sum of the lengths of two source phrases in a reordering example .
For each length , we randomly select 200 unseen reordering examples to calculate the classification accuracy .
Our classifier outperforms the baseline consistently , especially for long composed blocks .
Xiong et al. ( 2008 ) find that the performance of the baseline system can be improved by forbidding inverted reordering if the phrase length exceeds a pre-defined distortion limit .
This heuristic increases the BLEU score of the baseline system significantly to 24.46 but is still significantly worse ( p < 0.05 ) than our system without the heuristic .
We find that imposing this heuristic fails to improve our system cluster 1 cluster 2 cluster 3 cluster 4 cluster 5 1.18 works for alternative duties these people who of the three accessibility verify on one - day conference the reasons why on the fundamental wheelchair tunnels from armed groups the story of how over the entire candies transparency in chinese language works the system which through its own cough opinion at eating habits the trend towards with the best Table 4 : Words and phrases that are close in the Euclidean space .
The words and phrases in the same cluster have similar behaviors from a reordering point of view rather than relatedness , suggesting that the vector representations produced by the recursive autoencoders are helpful for capturing reordering regularities .
significantly .
One possible reason is that there is limited room for improvement as our system makes fewer wrong predictions for long composed blocks .
The above results suggest that our system does go beyond using boundary words and make a better use of the merging blocks by using vector space representations .
Table 3 shows the effect of training dataset size on BLEU scores .
We find that BLEU scores on both the development and test sets rise with the increase of the training dataset size .
As the training process is very time - consuming , only the reordering examples extracted from 1/5 of the entire parallel training corpus are used in our experiments to train our model .
Obviously , with more efficient training algorithms , making full use of all the reordering examples extracted from the entire corpus will result in better results .
We leave this for future work .
Qualitative Analysis on Vector Representations
Table 4 shows a number of words and phrases that are close ( measured by Euclidean distance ) in the n-dimensional space .
We randomly select about 370 K target side phrases used in our experiments and cluster them into 983 clusters using k-means algorithm ( MacQueen , 1967 ) .
The distance between two phrases are measured by the Euclidean distance between their vector representations .
As shown in Table 4 , cluster 1 mainly consists of nouns , cluster 2 mainly contains verb / noun + preposition structures , cluster 3 contains compound phrases , cluster 4 consists of phrases which should be followed by a clause , and cluster 5 mainly contains the beginning parts of prepositional phrases that tend to be followed by a noun phrase or word .
We find that the words and phrases in the same cluster have sim-ilar behaviors from a reordering point of view rather than relatedness .
This indicates that the vector representations produced by the recursive autoencoders are helpful for capturing reordering regularities .
Conclusion
We have presented an ITG reordering classifier based on recursive autoencoders .
As recursive autoencoders are capable of producing vector space representations for arbitrary multi-word strings in decoding , our neural ITG system achieves an absolute improvement of 1.07 BLEU points over the baseline on the NIST 2008 Chinese - English dataset .
There are a number of interesting directions we would like to pursue in the near future .
First , replacing the MaxEnt classifier with a neural one redefines the conditions for risk - free hypothesis recombination .
We find that the number of hypotheses that can be recombined reduces in our system .
Therefore , we plan to use forest reranking ( Huang , 2008 ) to alleviate this problem .
Second , it is interesting to follow Socher et al . ( 2013 ) to combine linguistically -motivated labels with recursive neural networks .
Another problem with our system is that the decoding speed is much slower than the baseline system because of the computational overhead introduced by RAEs .
It is necessary to investigate more efficient decoding algorithms .
Finally , it is possible to apply our method to other phrase - based and even syntax - based systems .
Figure 3 : 3 Figure 3 : A neural ITG reordering model .
The binary classifier makes decisions based on the vector space representations of the source and target sides of merging blocks .
