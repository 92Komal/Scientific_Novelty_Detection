title
Extraction Programs : A Unified Approach to Translation Rule Extraction
abstract
We provide a general algorithmic schema for translation rule extraction and show that several popular extraction methods ( including phrase pair extraction , hierarchical phrase pair extraction , and GHKM extraction ) can be viewed as specific instances of this schema .
This work is primarily intended as a survey of the dominant extraction paradigms , in which we make explicit the close relationship between these approaches , and establish a language for future hybridizations .
This facilitates a generic and extensible implementation of alignment - based extraction methods .
Introduction
The tradition of extracting translation rules from aligned sentence pairs dates back more than a decade .
A prominent early example is phrase - based extraction ( Och et al. , 1999 ) .
Around the middle of the last decade , two extraction paradigms were proposed for syntax - based machine translation : the Hiero paradigm of ( Chiang , 2005 ) and the GHKM paradigm of ( Galley et al. , 2004 ) .
From these papers followed two largely independent lines of research , respectively dubbed formally syntax - based machine translation ( Chiang , 2007 ; Zollmann and Venugopal , 2006 ; Venugopal et al. , 2007 ; Lopez , 2007 ; Marton and Resnik , 2008 ; Li et al. , 2009 ; de Gispert et al. , 2010 ) and linguistically syntax - based machine translation ( Galley et al. , 2006 ; Liu et al. , 2006 ; Huang et al. , 2006 ; Liu et al. , 2007 ; Mi and Huang , 2008 ; Zhang et al. , 2008 ; Liu et al. , 2009 ) .
In this paper , we unify these strands of research by showing how to express Hiero extraction , GHKM extraction , and phrase - based extraction as instances of a single master extraction method .
Specifically , we express each technique as a simple " program " given to a generic " evaluator " .
Table 1 summarizes how to express several popular extraction methods as " extraction programs . "
Besides providing a unifying survey of popular alignment - based extraction methods , this work has the practical benefit of facilitating the implementation of these methods .
By specifying the appropriate input program , the generic evaluator ( coded , say , as a Python module ) can be used to execute any of the extraction techniques in Table 1 . New extraction techniques and hybridizations of existing techniques can be supported with minimal additional programming .
Building Blocks
The family of extraction algorithms under consideration share a common setup : they extract translation rules from a sentence pair and an alignment .
In this section , we define these concepts .
Patterns and Sentences Assume we have a global vocabulary of atomic symbols , containing the reserved substitution symbol ?.
Define a pattern as a sequence of symbols .
Define the rank of a pattern as the count of its ? symbols .
Let ? k k ? , ? , ... , ? .
We will typically use space-delimited quotations to represent example patterns , e.g. " ne ? pas " rather than ne , ? , pas .
We will use the dot operator to represent the concatenation of patterns , e.g. " il ne " ?
" va pas " = " il ne va pas " .
Extraction Program Method Primary Secondary Labeling Protocol Protocol Protocol PBMT ( Och et al. , 1999 ) RANKPP 0 TRIVSP A TRIVLP Hiero ( Chiang , 2005 ) RANKPP ? TRIVSP A TRIVLP GHKM ( Galley et al. , 2004 ) MAPPP t TRIVSP A PMAPLP t SAMT ( Zollmann and Venugopal , 2006 ) RANKPP ? TRIVSP A PMAPLP t Forest GHKM ( Mi and Huang , 2008 ) MAPPP T TRIVSP A PMAPLP T Tree-to- Tree GHKM ( Liu et al. , 2009 ) MAPPP t MAPSP ?, A IMAPLP { t} , {? } Forest-to- Forest GHKM ( Liu et al. , 2009 ) MAPPP T MAPSP T , A IMAPLP T , T Fuzzy Dual Syntax ( Chiang , 2010 ) MAPPP t MAPSP ? , A IMAPLP { t} , {? }
We refer to a contiguous portion of a pattern with a span , defined as either the null span ? , or a pair Finally , define a sentence as a pattern of rank 0 .
Alignments
An alignment is a triple m , n , A , where m and n are positive integers , and A is a set of ordered integer pairs ( i , j ) such that 1 ? i ? m and 1 ? j ? n. In Figure 1 ( a ) , we show a graphical depiction of alignment 4 , 6 , { ( 1 , 1 ) , ( 2 , 3 ) , ( 4 , 3 ) , ( 3 , 5 ) } .
Observe that alignments have a primary side ( top ) and a secondary side ( bottom ) 1 . For alignment A = m , n , A , define | A | p = m and | A | s = n. A primary index ( resp. , secondary index ) of A is any positive integer less than or equal to | A | p ( resp. , | A| s ) .
A primary span ( resp. , secondary span ) of A is any span [ b , c] such that 1 ? b ? c ? | A| p ( resp. , | A| s ) .
Define a A ? ? to mean that ( a , ? ) ?
A ( in words , we say that A aligns primary index a to secondary 1
The terms primary and secondary allow us to be agnostic about how the extracted rules are used in a translation system , i.e. the primary side can refer to the source or target language .
index ? ) , and define a A ? ? to mean that ( a , ? ) ?
A. Define an aligned sentence pair as a triple s , ? , A where A is an alignment and s , ? are sentences of length | A | p and | A | s , respectively .
Primary and Secondary Domain :
The primary domain of alignment A is the set of primary indices that are aligned to some secondary index , i.e. Consider Figure 1 ( d ) .
We will also allow a more relaxed type of projection , in which we allow the broadening of the minimal projection to include unaligned secondary indices .
In the example , secondary spans [ 2 , 5 ] , [ 3 , 6 ] , and [ 2 , 6 ] ( in addition to the minimal projection [ 3 , 5 ] ) are all considered projections of primary span [ 2 , 4 ] . Formally , de- fine pproj A ( [ b , c ] ) as the set of superspans [ ? , ?] of pmproj A ( [ b , c ] ) such that [ ? , ?] ? sdom ( A ) ? pmproj A ( [ b , c ] ) .
Rules
We define an unlabeled rule as a tuple k , s * , ? * , ?
where k is a nonnegative integer , s * and ? * are patterns of rank k , and ? is a permutation of the sequence 1 , 2 , ... , k .
Such rules can be rewritten using a more standard Synchronous Context - Free Grammar ( SCFG ) format , e.g. 3 , " le ? ? de ? " , " ? 's ? ? " , 3 , 2 , 1 can be written : ? ? le ? 1 ? 2 de ?
3 , ? 3 's ?
2 ? 1 .
A labeled rule is a pair r , l , where r is an unlabeled rule , and l is a " label " .
The unlabeled rule defines the essential structure of a rule .
The label gives us auxiliary information we can use as decoding constraints or rule features .
This deliberate modularization lets us unify sequence - based and treebased extraction methods .
Labels can take many forms .
Two examples ( depicted in Figure 2 ) are : 1 . An SCFG label is a ( k + 1 ) - length sequence of symbols .
? le ? 1 ? 2 de ?
3 , ? 3 's ?
2 ? 1 . 2 . An STSG label ( from Synchronous Tree Substitution Grammar ( Eisner , 2003 ) ) is a pair of trees .
STSG labels subsume SCFG labels .
Thus STSG extraction techniques can be used as SCFG extraction techniques by ignoring the extra hierarchical structure of the STSG label .
Due to space constraints , we will restrict our focus to SCFG labels .
When considering techniques originally formulated to extract STSG rules ( GHKM , for instance ) , we will consider their SCFG equivalents .
A General Rule Extraction Schema
In this section , we develop a general algorithmic schema for extracting rules from aligned sentence pairs .
We will do so by generalizing the GHKM algorithm ( Galley et al. , 2004 ) .
The process goes as follows : ?
Repeatedly : - Choose a " construction request , " which consists of a " primary subrequest " ( see Figure 3a ) and a " secondary subrequest " ( see Figure 3 b ) .
- Construct the unlabeled rule corresponding to this request ( see Figure 3 , bottom ) .
- Label the rule ( see Figure 2 ) .
Choose a Construction Request
The first step in the extraction process is to choose a " construction request , " which directs the algorithm about which unlabeled rule ( s ) we wish to construct .
A " construction request " consists of two " subrequests . "
Subrequests :
A subrequest is a nonempty sequence of non-null spans [ b 0 , c 0 ] , [ b 1 , c 1 ] , ... , [ b k , c k ] such that , for all 1 ? i < j ? k , [ b i , c i ] and [ b j , c j ] are disjoint proper 2 subsets of [ b 0 , c 0 ] .
If it also true that c i < b j , for all 1 ? i < j ? k , then the subrequest is called monotonic .
We refer to k as the rank of the subrequest .
We typically write subrequest [ b 0 , c 0 ] , [ b 1 , c 1 ] , ... , [ b k , c k ] using the notation : 2 If unary rules are desired , i.e. rules of the form ? ? ? , then this condition can be relaxed .
[ b 0 , c 0 ] [ b 1 , c 1 ] ... [ b k , c k ] or as [ b 0 , c 0 ] if k = 0 .
For subrequest x = [ b 0 , c 0 ] [ b 1 , c 1 ] ... [ b k , c k ] , define : covered ( x ) = ? k i=1 [ b i , c i ] uncovered ( x ) = [ b 0 , c 0 ] \covered ( x ) Primary Subrequests : Given an alignment A , define the set frontier ( A ) as the set of primary spans [ b , c ] of alignment A such that pmproj A ( [ b , c ] ) ) is nonempty and disjoint from pimage A ( [ 1 , b ? 1 ] ) ? pimage A ( [ c + 1 , | A | p ] ) .
3 Algorithm CONSTRUCTRULE s , ? , A ( x , ? ) : if construction request x , ? matches alignment A then {u 1 , ... , u p } = uncovered ( [ b 0 , c 0 ] [ b 1 , c 1 ] ... [ b k , c k ] ) {? 1 , ... , ? q } = uncovered ( [ ?
0 , ? 0 ] [?
1 , ? 1 ] ... [ ?
k , ? k ] ) s * = INDEXSORT ( b 1 , b 2 , ... , b k , u 1 , u 2 , ... , u p , k ? , ? , ... , ? , s u 1 , s u 2 , ... , s up ) ? * = INDEXSORT ( ?
1 , ? 2 , ... , ? k , ?
1 , ? 2 , ... , ? q , k ? , ? , ... , ? , ? ? 1 , ? ? 2 , ... , ? ?q ) ? = INDEXSORT ( ?
1 , ? 2 , ... , ? k , 1 , 2 , ... , k ) return { k , s * , ? * , ?
} else return { } end if = " ?
1 ? 2 ... ?
n " are sentences , A = m , n , A is an alignment , x = [ b 0 , c 0 ] [ b 1 , c 1 ] ... [ b k , c k ] and ? = [? 0 , ? 0 ] [?
1 , ? 1 ] ... [ ?
k , ? k ] are subrequests .
Define preqs ( A ) as the set of monotonic subrequests whose spans are all in frontier ( A ) .
We refer to members of preqs ( A ) as primary subrequests of alignment A. Figure 3a shows a primary subrequest of an example alignment .
Secondary Subrequests : Given a primary sub- request x = [ b 0 , c 0 ] [ b 1 , c 1 ] ... [ b k , c k ] of align - ment A , define sreqs ( x , A ) as the set of subrequests [ ?
0 , ? 0 ] [?
1 , ? 1 ] ... [ ?
k , ? k ] such that [ ?
i , ? i ] ? pproj A ( [ b i , c i ] ) , for all 0 ? i ? k.
We refer to members of sreqs ( x , A ) as secondary subrequests of primary subrequest x and alignment A. Figure 3 b shows a secondary subrequest of the primary subrequest selected in Figure 3a . Construction Requests :
A construction request is a pair of subrequests of equivalent rank .
Construction request x , ? matches alignment A if x ? preqs ( A ) and ? ? sreqs ( x , A ) .
Construct the Unlabeled Rule
The basis of rule construction is the INDEXSORT operator , which takes as input a sequence of integers I = i 1 , i 2 , ... , i k , and an equivalentlength sequence of arbitrary values v 1 , v 2 , ... , v k , and returns a sequence v j 1 , v j 2 , ... , v j k , where j 1 , j 2 , ... , j k is a permutation of sequence I in ascending order .
For instance , INDEX - SORT ( 4 , 1 , 50 , 2 , " a " , " b " , " c " , " d " ) = property is a property of the alignment alone .
It is independent of the auxiliary information that GHKM uses , in particular the tree .
Primary Protocol RANKPP k : " b " , " d " , " a " , " c " .
Note that the output of INDEXSORT ( I , V ) is nondeterministic if sequence I has repetitions .
In Figure 4 , we show the pseudocode for rule construction .
We show an example construction in Figure 3 ( bottom ) .
{ [ b 0 , c 0 ] [ b 1 , c 1 ] ... [ b j , c j ] s.t. 1 ? b 0 ? c 0 and 0 ? j ? k} Primary Protocol MAPPP t : { [ b 0 , c 0 ] [ b 1 , c 1 ] ... [ b k , c k ] s.t. ?0 ? i ? k [ b i , c i ] ?
Label the Rule Rule construction produces unlabeled rules .
To label these rules , we use a labeling protocol , defined as a function that takes a construction request as input , and returns a set of labels .
Figure 7 defines a number of general- purpose la-Secondary Protocol TRIVSP A ( x ) : return sreqs ( x , A ) Secondary Protocol MAPSP ?, A ( x ) : { [ ? 0 , ? 0 ] [?
1 , ? 1 ] ... [ ?
k , ? k ] ? sreqs ( x , A ) s.t. ?0 ? i ? k : [?
i , ? i ] ? spans ( ? ) } ; x = [ b 0 , c 0 ] [ b 1 , c 1 ] ... [ b k , c k ] is a subrequest .
beling protocols .
Some of these are driven by trees .
We will represent a tree as a spanmap , defined as a function that maps spans to symbol sequences .
For instance , if a parse tree has constituent NP over span [ 4 , 7 ] , then the corresponding spanmap t has t ( [ 4 , 7 ] ) = NP .
We map spans to sequences in order to accommodate unary chains in the parse tree .
Nonconstituent spans are mapped to the empty sequence .
For spanmap t , let spans ( t ) be the set of spans [ b , c] for which t( [ b , c ] ) is a nonempty sequence .
Extraction Programs
In the previous section , we developed a general technique for extracting labeled rules from aligned sentence pairs .
Note that this was not an algorithm , but rather an algorithmic schema , as it left two questions unanswered : 1 . What construction requests do we make ?
What labeling protocol do we use ?
We answer these questions with an extraction program , defined as a triple X , ? , L , where : ?
X is a set of subrequests , referred to as the primary protocol .
It specifies the set of primary subrequests that interest us .
Figure 5 defines some general - purpose primary protocols .
? ? maps every subrequest to a set of subrequests .
We refer to ? as the secondary protocol .
It specifies the set of secondary subrequests that interest us , given a particular primary subrequest .
Figure 6 defines some general - purpose secondary protocols .
Labeling Protocol TRIVLP ( x , ? ) : return ? k+1 Labeling Protocol PMAPLP t ( x , ? ) : { l 0 , ... , l k s.t. ?0 ? i ? k : l i ? t( [ b i , c i ] ) }
Labeling Protocol PMAPLP T ( x , ? ) : t?T PMAPLP t ( x , ? ) Labeling Protocol SMAPLP ? ( x , ? ) : { ? 0 , ... , ? k s.t. ?0 ? i ? k : ? i ? ? ( [ ? i , ? i ] ) }
Labeling Protocol SMAPLP T ( x , ? ) : ? ?T SMAPLP ? ( x , ? ) Labeling Protocol IMAPLP T, T ( x , ? ) : { ( l 0 , ? 0 ) , ... , ( l k , ? k ) s.t. l 0 , ... , l k ? PMAPLP T ( x , ? ) and ? 0 , ... , ? k ? SMAPLP T ( x , ? ) } ?
L is a labeling protocol .
Figure 7 defines some general - purpose labeling protocols .
Figure 8 shows the pseudocode for an " evaluator " that takes an extraction program ( and an aligned sentence pair ) as input and returns a set of labeled rules .
The GHKM Extraction Program
As previously stated , we developed our extraction schema by generalizing the GHKM algorithm ( Galley et al. , 2004 ) .
To recover GHKM as an instance of this schema , use the following program : EXTRACT s , ? , A ( MAPPP t , TRIVSP A , PMAPLP t ) where t is a spanmap encoding a parse tree over the primary sentence .
Algorithm EXTRACT s , ? , A ( X , ? , L ) : R = {} for all subrequests x ?
X do for all subrequests ? ? ?( x ) do s , ? , A is an aligned sentence pair ; X is a primary protocol ; ? is a secondary protocol ; L is a labeling protocol .
U = CONSTRUCTRULE s , ? , A ( x , ? ) L = L(x , ? ) R = R ? ( U ? L ) end for end for return R
The Phrase Pair Extraction Program
In this section , we express phrase pair extraction ( Och et al. , 1999 ) as an extraction program .
For primary span [ b , c] and secondary span [ ? , ?] of alignment A , let [ b , c] A ? [ ? , ?] if the following three conditions hold : 1 . a A ? ? for some a ? [ b , c ] and ? ? [ ? , ?]
2 . a A ? ? for all a ? [ b , c ] and ? ? [ ? , ?]
3 . a A ? ? for all a ? [ b , c ] and ? ? [ ? , ?]
Define the ruleset PBMT (s , ? , A ) to be the set of labeled rules r , ?
1 such that : ? r = 0 , " s b ...s c " , " ? ? ...? ? " , ? ? [ b , c] A ? [ ? , ?]
We want to express PBMT (s , ? , A ) as an extraction program .
First we establish a useful lemma and corollary .
Lemma 1 . [ b , c] A ? [ ? , ?] iff [ b , c ] ? frontier ( A ) and [ ? , ?] ? pproj A ( [ b , c ] ) .
Proof .
Let [ b , c ] c = [ 1 , b ? 1 ] ? [ c + 1 , | A | p ] . [ b , c ] ? frontier ( A ) and [ ? , ?] ? pproj A ( [ b , c ] ) ( 1 ) ? pmproj A ( [ b , c ] ) ? pimage A ( [ b , c ] c ) = { } [ ? , ?] ? pproj A ( [ b , c ] ) ( 2 ) ? [ ? , ?] ? pimage A ( [ b , c ] c ) = { } [ ? , ?] ? pproj A ( [ b , c ] ) ( 3 ) ? [ ? , ?] ? pimage A ( [ b , c ] c ) = {} pimage A ( [ b , c ] ) ? [ ? , ?] ( 4 ) ? conditions 2 and 3 hold [ ? , ?] = {} Corollary 2 . Consider monotonic subrequest x = [ b 0 , c 0 ] [ b 1 , c 1 ] ... [ b k , c k ] and arbitary subrequest ? = [? 0 , ? 0 ] [?
1 , ? 1 ] ... [ ?
k , ? k ] .
Construction request x , ? matches alignment A iff [ b i , c i ]
A ? [?
i , ? i ] for all 0 ? i ? k.
We are now ready to express the rule set PBMT (s , ? , A ) as an extraction program .
Theorem 3 . PBMT (s , ? , A ) = EXTRACT s , ? , A ( RANKPP 0 , TRIVSP A , TRIVLP ) Proof. r , l ? EXT s , ? , A ( RANKPP 0 , TRIVSP A , TRIVLP ) ( 1 ) ? ? ? ? ? ? ? ? ? ? ? ? x = [ b , c] and ? = [ ? , ?] x , ? matches alignment A {r} = CONSTRUCTRULE s , ? , A ( x , ? ) l = ? 1 ( 2 ) ? ? ? ? ? ? ? ? ? ? ? ? x = [ b , c] and ? = [ ? , ?] x , ? matches alignment A r = 0 , " s b ...s c " , " ? ? ...? ? " , ? l = ? 1 ( 3 ) ? ? ? ? ? ? ? ? [ b , c] A ? [ ? , ?]
r = 0 , " s b ...s c " , " ? ? ...? ? " , ? l = ? 1 ( 4 ) ? r , l ? PBMT(s , ? , A ) Equivalence 1 holds by the definition of EXTRACT and RANKPP 0 . Equivalence 2 holds by the pseudocode of CONSTRUCTRULE .
Equivalence 3 holds from Corollary 2 .
Equivalence 4 holds from the definition of PBMT (s , ? , A ) .
The Hiero Extraction Program
In this section , we express the hierarchical phrasebased extraction technique of ( Chiang , 2007 ) as an extraction program .
Define HIERO 0 ( s , ? , A ) = PBMT (s , ? , A ) .
For positive integer k , define HIERO k ( s , ? , A ) as the smallest superset of HI - ERO k?1 ( s , ? , A ) satisfying the following condition : ?
For any labeled rule k ?
1 , s * , ? * , ? , ? k ? HIERO k?1 ( s , ? , A ) such that :
1 . s * = s * 1 ? " s b ...s c " ? s * 2 2 . ? * = ? * 1 ? " ? ? ...? ? " ? ? * 2 3 . ? = ? 1 , ? 2 , ... , ? k?1 4 . s * 2 has rank 0 . 4 5 . ? * 1 has rank j. 6 . [ b , c] A ? [ ? , ?] it holds that labeled rule r , ? k+1 is a member of HIERO k ( s , ? , A ) , where r is : k , s * 1 ? " ? " ? s * 2 , ? * 1 ? " ? " ? ? * 2 , ? 1 , ... , ? j , k , ? j+1 , ... , ? k?1 Theorem 4 . HIERO k ( s , ? , A ) = EXTRACT s , ? , A ( RANKPP k , TRIVSP A , TRIVLP ) Proof .
By induction .
Define ext ( k ) to mean EXTRACT s , ? , A ( RANKPP k , TRIVSP A , TRIVLP ) .
From Theorem 3 , HIERO 0 ( s , ? , A ) = ext ( 0 ) .
Assume that HIERO k?1 ( s , ? , A ) = ext ( k ? 1 ) and prove that HIERO k ( s , ? , A ) \HIERO k?1 ( s , ? , A ) = ext ( k ) \ext ( k ? 1 ) . r , l ? ext ( k ) \ext ( k ? 1 ) ( 1 ) ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? x = [ b 0 , c 0 ] [ b 1 , c 1 ] ... [ b k , c k ] ? = [? 0 , ? 0 ] [?
1 , ? 1 ] ... [ ?
k , ? k ] x , ? matches alignment A {r } = CONSTRUCTRULE s , ? , A ( x , ? ) l = ? k+1 4
This condition is not in the original definition .
It is a cosmetic addition , to enforce the consecutive ordering of variable indices on the rule LHS .
( 2 ) ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? x = [ b 0 , c 0 ] [ b 1 , c 1 ] ... [ b k?1 , c k?1 ] ? = [? 0 , ? 0 ] [?
1 , ? 1 ] ... [ ? k?1 , ? k?1 ] {r} = CONSTRUCTRULE s , ? , A ( x , ? ) ? = ? 1 , ... , ? k?1 r = k ?
1 , s * 1 ? " s b k ...s c k " ? s * 2 , ? * 1 ? " ? ? k ...? ? k " ? ? * 2 , ? s * 2 has rank 0 and ? * 1 has rank j x = [ b 0 , c 0 ] [ b 1 , c 1 ] ... [ b k , c k ] ? = [? 0 , ? 0 ] [?
1 , ? 1 ] ... [ ?
k , ? k ] x , ? matches alignment A ? = ? 1 , ... , ? j , k , ? j+1 , ... , ? k?1 r = k , s * 1 ? " ? " ? s * 2 , ? * 1 ? " ? " ? ? * 2 , ? l = ? k +1 ( 3 ) ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? = ? 1 , ... , ? k?1 r = k ?
1 , s * 1 ? " s b k ...s c k " ? s * 2 , ? * 1 ? " ? ? k ...? ? k " ? ? * 2 , ? s * 2 has rank 0 and ? * 1 has rank j r , ? k ? HIERO k?1 ( s , ? , A ) ? = ? 1 , ... , ? j , k , ? j+1 , ... , ? k?1 r = k , s * 1 ? " ? " ? s * 2 , ? * 1 ? " ? " ? ? * 2 , ? [ b i , c i ]
A ? [?
i , ? i ] for all 0 ? i ? k l = ? k +1 ( 4 ) ? r , l ?
HIERO k ( s , ? , A ) \HIERO k?1 ( s , ? , A ) Equivalence 1 holds by the definition of ext ( k ) \ext ( k ? 1 ) .
Equivalence 2 holds by the pseudocode of CONSTRUCTRULE .
Equivalence 3 holds by the inductive hypothesis and Corollary 2 .
Equivalence 4 holds by the definition of HIERO k ( s , ? , A ) \HIERO k?1 ( s , ? , A ) .
Discussion
In this paper , we have created a framework that allows us to express a desired rule extraction method as a set of construction requests and a labeling protocol .
This enables a modular , " mix -and- match " approach to rule extraction .
In Table 1 , we summarize the results of this paper , as well as our conjectured extraction programs for several other methods .
For instance , Syntax -Augmented Machine Translation ( SAMT ) ( Zollmann and Venugopal , 2006 ) is a hybridization of Hiero and GHKM that uses the primary protocol of Hiero and the labeling protocol of GHKM .
To bridge the approaches , SAMT employs a fuzzy version 5 of the spanmap t that assigns a trivial label to non-constituent primary spans : t( [ b , c ] ) = t ( [ b , c ] ) if [ b , c ] ? spans ( t ) ? otherwise
Other approaches can be similarly expressed as straightforward variants of the extraction programs we have developed in this paper .
Although we have focused on idealized methods , this framework also allows a compact and precise characterization of practical restrictions of these techniques .
For instance , ( Chiang , 2007 ) lists six criteria that he uses in practice to restrict the generation of Hiero rules .
His condition 4 ( " Rules can have at most two nonterminals . " ) and condition 5 ( " It is prohibited for nonterminals to be adjacent on the French side . " ) can be jointly captured by replacing Hiero 's primary protocol with the following :
His other conditions can be similarly captured with appropriate changes to Hiero 's primary and secondary protocols .
This work is primarily intended as a survey of the dominant translation rule extraction paradigms , in which we make explicit the close relationship between these approaches , and establish a language for future hybridizations .
From a practical perspective , we facilitate a generic and extensible implementation which supports a wide variety of existing methods , and which permits the precise expression of practical extraction heuristics .
5
This corresponds with the original formulation of Syntax Augmented Machine Translation ( Zollmann and Venugopal , 2006 ) .
More recent versions of SAMT adopt a more refined " fuzzifier " that assigns hybrid labels to non-constituent primary spans . [ b , c ] of positive integers such that b ? c. We will treat span [ b , c ] as the implicit encoding of the set { b , b + 1 , ... , c} , and employ set-theoretic operations on spans , e.g. [ 3 , 8 ] ? [ 6 , 11 ] = [ 6 , 8 ] .
Note that the null span encodes the empty set .
If a set I of positive integers is non-empty , then it has a unique minimal enclosing span , defined by the operator spa n ( I ) = [ min ( I ) , ma x ( I ) ] .
For instance , span ( { 1 , 3 , 4 } ) = [ 1 , 4 ] .
Define span ( { } ) = ?.
Figure 1 : 1 Figure 1 : A demonstration of alignment terminology .
( a) An alignment is a relation between positive integer sets .
( b) The primary domain of the example alignment is { 1,2,3,4 } and the secondary domain is { 1,3,5 } .
( c ) The image of primary span [ 2,4 ] is { 3,5 } .
( d ) The minimal projection of primary span [ 2,4 ] is [ 3,5 ] .
Secondary spans [ 2,5 ] , [ 3,6 ] , and [ 2,6 ] are also projections of primary span [ 2,4 ] .
pdom ( A ) = { a|? s.t. a A ? ?}. Analogously , define sdom ( A ) = {?|? a s.t. a A ? ?}.
For the example alignment of Figure 1 ( b ) , pdom ( A ) = { 1 , 2 , 3 , 4 } and sdom ( A ) = { 1 , 3 , 5 } .
Image :
The image of a set I of primary indices ( denoted pimage A ( I ) ) is the set of secondary indices to which the primary indices of I align .
In Figure 1 ( c ) , for instance , the image of primary span [ 2 , 4 ] is the set { 3 , 5 } .
Formally , for a set I of primary indices of alignment A , define : pimage A ( I ) = {?|? a ? I s.t. ( a , ? ) ?
A} Projection :
The minimal projection of a set I of primary indices ( denoted pmproj A ( I ) ) is the minimal enclosing span of the image of I .
In other words , pmproj A ( I ) = span( pimage A ( I ) ) .
In Figure 1 ( d ) , for instance , the minimal projection of primary span [ 2 , 4 ] is the secondary span [ 3 , 5 ] .
Figure 2 : An example SCFG label ( top ) and STSG label ( bottom ) for unlabeled rule ? le ? 1 ? 2 de ?
3 , ? 3 's ?
2 ? 1 .
Figure 3 : 3 Figure 3 : Extraction of the unlabeled rule ? ? ?
1 does not ?
2 , ? 1 ne ?
2 pas . ( a ) Choose primary subrequest [ 1 , 4 ] [ 1 , 1 ] [ 4 , 4 ] .
( b) Choose secondary subrequest [ 1 , 4 ] [ 1 , 1 ] [ 3 , 3 ] .
( bottom ) Construct the rule ? ? ?
1 does not ?
2 , ? 1 ne ?
2 pas .
Figure 4 : 4 Figure 4 : Pseudocode for rule construction .
Arguments : s= " s 1 s 2 ... s m " and ? = " ?
1 ? 2 ... ?
n " are sentences , A = m , n , A is an alignment , x = [ b 0 , c 0 ] [ b 1 , c 1 ] ... [ b k , c k ] and ? = [? 0 , ? 0 ] [?
1 , ? 1 ] ... [ ?
k , ? k ] are subrequests .
Figure 6 : 6 Figure 6 : Various secondary protocols .
Parameters : ? is a spanmap ; A is an alignment ; x = [ b 0 , c 0 ] [ b 1 , c 1 ] ... [ b k , c k ] is a subrequest .
Figure 7 : 7 Figure 7 : Various labeling protocols .
Parameters : t , ? are spanmaps ; T , T are sets of spanmaps ; x = [ b 0 , c 0 ] [ b 1 , c 1 ] ... [ b k , c k ] and ? = [? 0 , ? 0 ] [?
1 , ? 1 ] ... [ ?
k , ? k ] are subrequests .
Figure 8 : 8 Figure 8 : Evaluator for extraction programs .
Parameters:s , ? , A is an aligned sentence pair ; X is a primary protocol ; ? is a secondary protocol ; L is a labeling protocol .
by definition of frontier ( A ) .
Equivalence 2 holds because [ ? , ?] differs from pmproj A ( [ b , c ] ) only in unaligned indices .
Equivalence 3 holds because given the disjointness from pimage A ( [ b , c ] c ) , [ ? , ?] differs from pimage A ( [ b , c ] ) only in unaligned indices .
Equivalences 4 and 5 are a restatement of conditions 2 and 3 plus the observation that empty spans can satisfy conditions 2 and 3 .
{ [ b 0 , c 0 ] [ b 1 , c 1 ] ... [ b j , c j ] s.t. 1 ? b 0 ? c 0 0 ? j ? 2 b 2 > c 1 + 1 }
Table 1 : 1 Various rule extraction methods , expressed as extraction programs .
Boldfaced methods are proven in this paper ; the rest are left as conjecture .
Parameters : t , ? are spanmaps ( see Section 3 ) ; t , ? are fuzzy spanmaps ( see Section 7 ) ; T , T are sets of spanmaps ( typically encoded as forests ) ; A is an alignment ( see Section 2 ) .
Our definition of the frontier property is an equivalent reexpression of that given in ( Galley et al. , 2004 ) .
We reexpress it in these terms in order to highlight the fact that the frontier
