title
Universal Morpho-syntactic Parsing and the Contribution of Lexica : Analyzing the ONLP Lab Submission to the CoNLL 2018 Shared Task
abstract
We present the contribution of the ONLP lab at the Open University of Israel to the CONLL 2018 UD SHARED TASK on MULTILINGUAL PARSING FROM RAW TEXT TO UNIVERSAL DEPENDENCIES .
Our contribution is based on a transitionbased parser called yap : yet another parser which includes a standalone morphological model , a standalone dependency model , and a joint morphosyntactic model .
In the task we used yap 's standalone dependency parser to parse input morphologically disambiguated by UD - Pipe , and obtained the official score of 58.35 LAS .
In a follow up investigation we use yap to show how the incorporation of morphological and lexical resources may improve the performance of end-to - end raw-to - dependencies parsing in the case of a morphologically - rich and low-resource language , Modern Hebrew .
Our results on Hebrew underscore the importance of CoNLL - UL , a UD - compatible standard for accessing external lexical resources , for enhancing end-to - end UD parsing , in particular for morphologically rich and low-resource languages .
We thus encourage the community to create , convert , or make available more such lexica .
Introduction
The Universal Dependencies ( UD ) initiative 1 is an international , cross-linguistic and cross-cultural initiative aimed at providing morpho-syntactically annotated data sets for the world 's languages under a unified , harmonized , annotation scheme .
1
universaldependencies.org
The UD scheme ( Nivre et al. , 2016 ) adheres to two main principles : ( i ) there is a single set of POS tags , morphological properties , and dependency labels for all treebanks , and their annotation obeys a single set of annotation principles , and ( ii ) the text is represented in a two -level representation , clearly mapping the written spacedelimited source tokens to the ( morpho ) syntactic words which participate in the dependency tree .
The CONLL 2018 UD SHARED TASK is a multilingual parsing evaluation campaign wherein , contrary to previous shared tasks such as CoNLL -06/07 ( Buchholz and Marsi , 2006 ; Nivre et al. , 2007 ) corpora are provided with raw text , and the end goal is to provide a complete morpho-syntactic representation , including automatically resolving all of the token - word discrepancies .
Contrary to the previous SPMRL shared tasks ( Seddah et al. , 2013 ( Seddah et al. , , 2014 , the output of all systems obeys a single annotation scheme , allowing for reliable cross-system and cross-language evaluation .
This paper presents the system submitted by the ONLP lab to the shared task , including the dependency models trained on the train sets , assuming morphologically disambiguated input tokens by UDpipe ( Straka et al. , 2016 ) .
We successfully parsed 81 test treebanks of UDv2 set ( Nivre et al. , 2017 ) participating in the CONLL 2018 UD SHARED TASK ( Zeman et al. , 2018 ) , obtaining the official score of LAS 58.35 average on all treebanks .
We then present an analysis of case of Modern Hebrew , a low-resource morphologically rich language ( MRL ) , which is known to be notoriously hard to parse , due to its high morphological word ambiguity and the small size of the treebank .
We investigate the contribution of an external lexicon and a standalone morphological component , and show that inclusion of such lexica can lead to above 10 % LAS improvement on this MRL .
Our investigation demonstrates the importance of sharing not only syntactic treebanks but also lexical resources among the UD community , and we propose the UD - compatible CoNLL - UL standard for external lexica ( More et al. , 2018 ) for sharing broad-coverage lexical resources in the next UD shared tasks , and in general .
The remainder of this document is organized as follows :
In Section 2 , we present our parser 's formal system and statistical models .
In Section 3 we present technical issues relevant to the official run for the shared task followed by our results on all languages .
In Section 4 we proceed with an analysis of the performance on Modern Hebrew in the task , compared against its performance augmented with a lexicon - backed morphological analyzer .
We finally discuss in Section 5 directions for future work and conclude by embracing the CoNLL - UL standard ( More et al. , 2018 ) for UDanchored lexical resource as means to facilitate and improve raw-to- dependencies UD parsing .
Our Framework
The parsing system presented by the ONLP Lab for this task is based on yap - yet another parser , a transition - based parsing system that relies on the formal framework of Zhang and Clark ( 2011 ) , an efficient computational framework designed for structure prediction and based on the generalized perceptron for learning and beam search for decoding .
This section briefly describes the formal settings and specific models available via yap .
2
Formal Settings
Formally , a transition system is a quadruple ( C , T , c s , C t ) where C is a set of configurations , T a set of transitions between the elements of C , c s an initialization function , and C t ?
C a set of terminal configurations .
A transition sequence y = t n ( t n?1 (...t 1 ( c s ( x ) ) ) ) for an input x starts with an initial configuration c s ( x ) and results in a terminal configuration c n ?
C t .
In order to determine which transition t ?
T to apply given a configuration c ?
C , we define a model that learns to predict the transition that would be chosen by an oracle function O : C ?
T , which has access to the gold output .
We employ an objective function F ( x ) = argmax y?GEN ( x ) Score( y ) 2 https://github.com/habeanf/yap which scores output candidates ( transition sequence in GEN ( x ) ) such that the most plausible sequence of transitions is the one that most closely resembles the one generated by an oracle .
To compute Score(y ) , y is mapped to a global feature vector ?( y ) = {? i ( y ) } where each feature ? i ( y ) is a count of occurrences of a pattern defined by a feature function .
Given this vector , Score(y ) is calculated as the dot product of ?( y ) and a weights vector ? : Score(y ) = ?( y ) ? ? = c j ?y i ? i ? i ( c j ) Following Zhang and Clark ( 2011 ) , we learn the weights vector ?
via the generalized perceptron , using the early - update averaged variant of Collins and Roark ( 2004 ) .
For decoding , the framework uses the beam search algorithm , which helps mitigate otherwise irrecoverable errors in the transition sequence .
Morphological Analysis
The input to the morphological disambiguation ( MD ) component in particular and to the yap parsing system in general is a lattice L representing all of the morphological analysis alternatives of k surface tokens of the input stream x = x 1 , ... , x k , such that each L i = M A( x i ) is generated by a morphological analysis ( MA ) component , the lattice concatenate the lattices for the whole input sentence x .
Each lattice - arc in L has a morphosyntactic representation ( MSR ) defined as m = ( b , e , f , t , g ) , with b and e marking the start and end nodes of m in L , f a form , t a universal partof-speech tag , and g a set of attribute=value universal features .
These lattice - arc correspond to potential nodes in the intended dependency tree .
Morphological Disambiguation
The morphological disambiguation ( MD ) component of our parser is based on More and Tsarfaty ( 2016 ) , modified to accommodate UD POS tags and morphological features .
We provide here a brief exposition of the transition system , as shall be needed for our later analysis , and refer the reader to the original paper for an in- depth discussion ( More and Tsarfaty , 2016 ) .
A configuration for morphological disambiguation C M D = ( L , n , i , M ) consists of a lattice L , an index n representing a node in L , an index i s.t. 0 ? i < k representing a specific token 's lattice , and a set of disambiguated morphemes M .
The initial configuration function is defined to be c s ( x ) = ( L , bottom ( L ) , 0 , ? ) , where L = M A( x 1 ) ? ... ? M A( x k ) , and n = bottom ( L ) , the bottom of the lattice .
A configuration is terminal when n = top ( L ) and i = k .
To traverse the lattice and disambiguate the input , we define an open set of transitions using the M D s transition template : M D s : ( L , p , i , M ) ? ( L , q , i , M ? { m } )
Where p = b , q = e , and s relates the transition to the disambiguated morpheme m using a parameterized delexicalization s = DLEX oc ( m ) : DLEX OC ( m ) = ( , , , t , g ) if t ? OC ( , , f , t , g ) otherwise
In words , DLEX projects a morpheme either with or without its form depending on whether or not the POS tag is an open-class with respect to the form .
For UD , we define : OC = { ADJ , AU X , ADV , P U N CT , N U M , IN T J,N OU N , P ROP N , V ERB } We use the parametric model of More and Tsarfaty ( 2016 ) to score the transitions at each step .
Since lattices may have paths of different length and we use beam search for decoding , the problem of variable - length transition sequences arises .
We follow More and Tsarfaty ( 2016 ) , using the EN DT OKEN transition to mitigate the biases induced by variable - length sequences .
Syntactic Disambiguation
A syntactic configuration is a triplet C DEP = ( ? , ? , A ) where ? is a stack , ? is a buffer , and A a set of labeled arcs .
For dependency parsing , we use a specific variant of Arc Eager that was first presented by ( Zhang and Nivre , 2011 ) .
The differences between plain arc-eager and the arc-zeager variant are detailed in Figure 1 .
The features defined for the parametric model also follows the definition of non-local features by Zhang and Nivre ( 2011 ) , with one difference : we created one version of each feature with a morphological signature ( all feature values of the relevant node ) and one without .
this allows to capture phenomena like agreement .
Joint Morpho-Syntactic Processing Given the standalone morphological and syntactic disambiguation it is possible to embed the two into a single joint morpho-syntactic transition system with a " router " that decides which of the transition systems to apply in a given configuration , and train the morphosyntactic model to maximize a single objective function .
We implement such joint parser in yap but we have not used it in the task , and we thus leave its description out of this exposition .
For further discussion and experiments with the syntactic and joint morpho-syntactic variants in yap we refer the reader to ( More et al. , In Press ) .
Shared Task Implementation
For sentence segmentation and tokenization up to and including full morphological disambiguation for all languages , we rely on the UDPipe ( Straka et al. , 2016 ) .
Our parsing system implementation is yap - yet another parser , an open-source natural language processor written in Go 3 .
Once compiled , the processor is a self-contained binary , without any dependencies on external libraries .
For the shared task the processor was compiled with Go version 1.10.3 .
During the test phase we wrapped the processor with a bash script that invoked yap serially on all the treebanks .
Additionally , in order to train on all treebanks we limited the size of all training sets to the first 50,000 sentences for the parser .
Finally , our training algorithm iterates until convergence , where performance is measured by F 1 for labeled attachment score when evaluated on languages ' respective development sets .
We define convergence as two consecutive iterations resulting in a monotonic decrease in F 1 for LAS , and used the best performing model up to that point .
For some languages we observed the F 1 never monotonically decreased twice , so after 20 iterations we manually stopped training and used the best performing model .
For some treebanks ( cs cac , fr sequoia , ru syntagrus ) the serialization code , which relies on Go 's built - in encoder package , failed to serialize the in-memory model because it is larger than 2 30 bytes .
To overcome the limitation we downloaded the go source code , manually changed the const field holding this limit and compiled the go source code .
Our strategy for parsing low resource languages was to use another treebank in the same language when such existed for the following : 211 Arc Eager : Conf. c = ( ? , ? , A ) ? h = A second , ' head ' stack Initial c s ( x = x 1 , ... , x n ) = ( [ 0 ] , [ 1 , ... , n ] , ? ) Terminal C t = { c ? C|c = ( [ 0 ] , [ ] , A ) } Transitions ( ? , [ i| ? ] , A ) ? ( [ ? | i ] , ? , A ) ( SHIFT ) ( [ ? | i ] , [ j| ? ] , A ) ? ( [ ?|i| j ] , ? , A ? {( i , l , j ) } ) ( ArcRight l ) if ( k , l , i ) / ?
A and i = 0 then ( [ ? | i ] , [ j| ? ] , A ) ? ( [ ? ] , [ j| ? ] , A ? {( j , l , i ) } ) ( ArcLeft l ) if ( k , l , i ) ?
A then ( [ ? | i ] , ? , A ) ? ( ? , ? , A ? {( i , l , j ) } ) ( REDUCE ) Arc ZEager : 2 and 3 present our official results for all languages .
Our system is ranked 22 with an average LAS score of 58.35 .
Our highest performing languages are Italian and Hindi - interestingly , both of which are considered morphologically rich , and both with LAS around 82 .
Our lowest performing languages ( with up to 20 LAS ) are the low-resource languages listed above , with Thai ( 0 LAS ) as an outlier .
Conf. c = ( ? , ? h , ? , A ) ? h = A second , ' head ' stack Initial c s ( x = x 1 , ... , x n ) = ( [ ] ? , [ ] h , [ 1 , ... , n ] , ? )
Note : no root Terminal C t = { c ? C|c = ( [ ] ? , ? h , [ ] , A ) }
For any ? h , A Transitions ( [ i ] ? , ? h , [ ] ? , A ) ? ( [ ] ? , ? h , [ ] ? , A ) ( POPROOT ) ( [ ? | i ] , ? h , [ ] ? , A ) ? ( ? , ? h , [ ] ? , A ) ( REDUCE 2 ) if T L ! =REDUCE then T L = Last Transition ( ? , ? h , [ i| ? ] , A ) ? ( [ ? | i ] , [? h | i ] , ? , A ) ( SHIFT ) if |?| > 0 and ( |?| > 1 and ( |?| > 1 or |? h | = 1 ) ) then ( [ ? | i ] , ? h , [ j| ? ] , A ) ? ( [ ?| i| j ] , ? h , ? , A ? {( i , l , j ) } ) ( ArcRight l ) if |?| > 0 and |?| > 0 then ( [ ? | i ] , ? h , ? , A ) ? ( [ ? ] , ? h , ? , A ? {( i , l , j ) } ) ( REDUCE 1 ) if |?| > 0 and |?| > 0 and ( k , l , i ) / ?
A and i = k then ( [ ? | i ] , [? h |k ] , [ j| ? ] , A ) ? ( [ ? ] , [? h ] , [ j| ? ] , A ? {( j , l , i ) } ) ( ArcLeft l )
The Case of MRLs : A Detailed Analysis for Modern Hebrew
As is well known , and as observed in this particular task , morphologically rich languages are most challenging to parse in the raw-to- dependencies parsing scenarios .
This is because the initial automatic segmentation and morphological disambiguation may contain irrecoverable errors which will undermine parsing performance .
In order to investigate the errors of our parser we took a particular MRL that is known to be hard to parse ( Modern Hebrew , ranked 58 in the LAS ranking , with basline 58.73 accuracy ) and contrasted the Baseline UDPipe results with the results of our parser , with and without the use of external lexical and morphological resources .
Table 1 lists the results of the different parsing models on our dev set .
In all of the parsing scenarios , we used UDPipe 's built in sentence segmentation , to make sure we parse the exact same sentences .
We then contrasted UDPipe 's full pipeline with the yap output for different morphological settings .
We used the Hebrew UD train set for training and the Hebrew UD for analyzing the empirical results .
Initially , we parsed the dev set with the same system we used for the shared task , namely , yap dependency parser which parses the morphologically diambiguated output by UDPipe ( yap DEP ) .
Here we see that yap DEP results ( 59.19 )
We then moved on to experiment with yap 's complete pipeline , including a data-driven morphological analyzer ( MA ) to produce input lattices , transition - based morphological disambiguation and transition - based parsing .
The results now dropped relative to the UDPipe baseline and relative to our own yap DEP system , from 59.19 to 52.25 LAS .
Now , interestingly , when we replace the baseline data-driven MA learned from the treebank alone with an MA backed with an external broad-coverage lexicon called HebLex ( adapted from ( Adler and Elhadad , 2006 ) ) , the LAS results arrive at 60.94 LAS , outperforming the results obtained by yap DEP ( UDPipe morphology with yap dependencies ) and close much of the gap with the UDPipe full model .
This suggests that much of the parser error stems from missing lexical knowledge concerning the morphologically rich and ambiguous word forms , rather than parser errors .
Finally , we simulated an ideal morphological lattices , by artificially infusing the path that indicates the correct disambiguation into the HebLex lattices in case it has been missing .
Note that we still provide an ambiguous input signal , with many possible morphological analyses , only now we guarantee that the correct analysis exists in the lattice .
For this setting , we see a significant improvement in LAS , obtaining 71.39 ( much beyond the baseline ) without changing any of the parsing algorithms involved .
So , for morphologically rich and ambiguous languages it appears that lexical coverage is a major factor affecting task performance , especially in the resource scarce case .
Note that the upper-bound of our parser , when given a completely disambiguated morphological input stream , provides LAS of 79.33 , which is a few points above the best system ( Stanford ) in the raw-to- dependencies scenario .
Discussion and Conclusion
This paper presents our submission to the CONLL 2018 UD SHARED TASK .
Our submitted system assumed UDpipe up to and including morphological disambiguation , and employed a state - of - theart transition - based parsing model to successfully parse 81 languages in the UDv2 set , with the average LAS of 58.35 , ranked 22 among the shared task participants .
A detailed post-task investigation of the performance that we conducted on Modern Hebrew , including the shared task and a number of variants , has shown that for the MRL case much of the parser errors may be attributed to incomplete morphological analyses or a complete lack thereof for the source tokens in the input stream .
In the future we intend to investigate sophisticated ways for incorporating additional external lexical and morphological knowledge , explicitely by means of broad-coverage lexica obeying the CoNLL - UL format ( More et al. , 2018 ) , or implicitly by means of pre-trained word embeddings on large volumes of data .
Note , however , that the utility of word-embedding themselves present an open questions in the case of morphologically rich and ambigous source token , where each token may be equivalent to multiple syntactic words in a language like English .
We additionally intend to replace the handcrafted feature model with neural - network based feature extraction mechanisms , and we aim to explore universal morphosyntactic parsing via joint morphosyntactic modeling , as previously advocated in different settings ( Tsarfaty and Goldberg , 2008 ; Bohnet and Nivre , 2012 ; Andor et al. , 2016 ; Bohnet et al. , 2013 ; Li et al. , 2011 ; Bohnet and Nivre , 2012 ; Li et al. , 2014 ; Figure 1 : 1 Figure 1 : Arc-Eager ( K?bler et al. , 2009 , Chapter 3 ) and Arc- ZEager ( Zhang and Nivre , 2011 ) Systems .
Table 1 : 1 are lower than the full UDPipe pipeline ( 61.95 ) .
The Contribution of Lexical Resources : Analysis of the Case for Modern Hebrew Model Lexicon Sentence Morphological Parser Results on dev Segmentation Disambiguation LAS / MLAS / BLEX UDPipe full - UDPipe UDPipe UDPipe 61.95 / 49.28 / 51.45 yap DEP - UDPipe UDPipe yap 59.19 / 49.19 / 33.75 yap full Basline UDPipe yap yap 52.25 / 37.85 / 29.59 HebLex 60.94 / 39.49 / 33.85 HebLex -Infused 71.39 / 61.42 / 41.86 yap GOLD - Gold Gold yap 79.33 / 72.56 / 47.62
Table 2 : 2 .. Official Shared - Task Results Treebank UAS LAS MLAS CLAS BLEX Treebank UAS LAS MLAS CLAS BLEX af afribooms 79.83 73.01 60.73 64.99 41.46 hy armtdp 40.83 25.04 8.42 17.09 6.96 ar padt 71.62 64.87 53.54 60.69 5.13 id gsd 82.19 72.23 61.93 70.05 41.53 bg btb 87.94 77.81 69.16 73.11 25.18 it isdt 89.25 82.22 72.45 75.06 52.7 br keb 26.46 7.01 0.42 3.06 1.98 it postwita 73.97 66.35 53.96 56.95 41.03 bxr bdt 30.52 11.14 1.65 4.71 2.52 ja gsd 74.21 68.45 52.96 54.81 50.63 ca ancora 86.94 80.49 70.37 72.92 53.34 ja modern 29.3 22.68 8.29 10.6 9.42 cs cac 85.41 76.25 64.77 73.22 24.89 kk ktb 37.92 17.34 4.33 9.25 2.89 cs fictree 84.33 72.63 59.28 68.01 29.12 kmr mg 35.77 25.1 7.77 19.95 6.53 cs pdt 83.09 74.6 65.51 72.12 29.79 ko gsd 69.4 55.13 49.99 51.85 17.26 cs pud 74.26 49.25 31.59 35.74 15.69 ko kaist 74.3 59.36 52.62 54.96 12.26 cu proiel 69.22 55.34 46.96 54.08 16.22 la ittb 72.77 63.19 54.81 60.29 21.93 da ddt 77.18 69.43 60.7 65.25 39.45 la perseus 43.97 28.12 16.31 23.67 7.46 de gsd 74.93 65.44 30.98 59.06 37.04 la proiel 59.01 48.13 36.96 43.96 14.95 el gdt 83.9 77.37 60.25 70.09 25.2 lv lvtb 73.29 59.67 46.27 54.42 20.58 en ewt 79.69 71 63.06 66.87 51.34 nl alpino 79.22 70.95 56.57 62.7 42.48 en gum 78.24 69.91 58.8 62.85 46.55 nl lassysmall 80.03 70.54 58.26 62.3 43.05 en lines 77.58 68.11 60.28 64.23 44.05 no bokmaal 86.01 77.43 69.77 74.18 43.89 en pud 72.12 63.73 53.73 58.79 43.33 no nynorsk 84.25 75.89 67.57 71.83 40.5 es ancora 87.61 81.55 73.01 75.48 52.31 no nynorsklia 58.15 42.21 32.58 36.57 30.99 et edt 76.5 64.52 56.69 61.37 21.73 pcm nsc 26.11 12.4 4.57 14.68 14.68 eu bdt 69.27 55.21 43.35 50.71 21.14 pl lfg 90.22 73.65 60.48 70.55 29.06 fa seraji 83.41 76.32 70.75 72.56 57.72 pl sz 85.38 71.87 54.81 68.9 22.67 fi ftb 75.5 59.82 48.98 52.84 16.82 pt bosque 84.35 77.46 62.64 69.99 52.06 fi pud 56.32 38.3 40.59 44.04 15.81 ro rrt 82.35 73.01 63.78 66.46 29.07 fi tdt 75.29 63.58 56.5 60.84 19.59 ru syntagrus 82.93 74.39 66.49 71.54 23.83 fo oft 41.41 18.92 0.36 11.98 5.07 ru taiga 61.97 48.86 31.77 42.96 18.03 fr gsd 84.89 78.15 69.18 72.91 50.51 sk snk 77.99 66.71 48.45 63.6 18.27 fr sequoia 83.7 77.93 69.18 72.92 49.55 sl ssj 78.61 71.24 57.51 67.57 23.79 fr spoken 69.94 61.29 51.17 52.69 41.01 sl sst 51.43 40.88 28.96 35.62 22.96 fro srcmf 84.56 68.55 62.02 64.67 64.67 sme giella 64.09 48.62 37.23 44.08 17.25 ga idt 72.64 59.62 34.63 47.71 25.64 sr set 85.41 76.78 64.7 73.57 24.1 gl ctg 80.39 75.59 63.47 68.3 40.79 sv lines 78.84 68.77 54.28 66.28 37.24 gl treegal 71.88 64.13 47.71 54.36 34.4 sv pud 70.7 42.7 16.79 30.36 16.14 got proiel 66.12 53.17 42.68 50.49 16.86 sv talbanken 82.12 73.24 65.84 70.02 36 grc perseus 46.75 35.21 17.91 28.08 5.24 th pud 0 0 0 0 0 grc proiel 64.75 55.52 38.44 46.53 7.58 tr imst 60.24 43.95 34.37 39.01 15.95 he htb 63.19 55.94 43.12 46.99 31.79 ug udt 67.47 45.67 28.89 35.67 24.12 hi hdtb 91.1 82.35 65.28 77.12 59.25 uk iu 78.45 69.36 51.42 64.69 21.97 hr set 83.32 73.71 54.4 70.23 22 .76 ur udtb 84.45 74.5 48.8 66.66 53.69 hsb ufal 38.15 26.84 4.73 19.27 3.98 vi vtb 45.43 37.05 32.18 33.78 33.78 hu szeged 68.53 54.32 41 48.46 30.73 zh gsd 62.77 55.97 46.88 51.02 50.74
Table 3 : 3 Official Shared - Task Results
https://golang.org
