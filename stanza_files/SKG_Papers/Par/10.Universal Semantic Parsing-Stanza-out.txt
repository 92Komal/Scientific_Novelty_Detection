title
Universal Semantic Parsing
abstract
Universal Dependencies ( UD ) offer a uniform cross-lingual syntactic representation , with the aim of advancing multilingual applications .
Recent work shows that semantic parsing can be accomplished by transforming syntactic dependencies to logical forms .
However , this work is limited to English , and cannot process dependency graphs , which allow handling complex phenomena such as control .
In this work , we introduce UDEPLAMBDA , a semantic interface for UD , which maps natural language to logical forms in an almost language - independent fashion and can process dependency graphs .
We perform experiments on question answering against Freebase and provide German and Spanish translations of the WebQuestions and GraphQuestions datasets to facilitate multilingual evaluation .
Results show that UDEPLAMBDA outperforms strong baselines across languages and datasets .
For English , it achieves a 4.9 F 1 point improvement over the state - of- the - art on Graph - Questions .
Introduction
The Universal Dependencies ( UD ) initiative seeks to develop cross-linguistically consistent annotation guidelines as well as a large number of uniformly annotated treebanks for many languages .
Such resources could advance multilingual applications of parsing , improve comparability of evaluation results , enable cross-lingual learning , and more generally support natural language understanding .
*
Work done at the University of Edinburgh Seeking to exploit the benefits of UD for natural language understanding , we introduce UDEP - LAMBDA , a semantic interface for UD that maps natural language to logical forms , representing underlying predicate - argument structures , in an almost language - independent manner .
Our framework is based on DEPLAMBDA a recently developed method that converts English Stanford Dependencies ( SD ) to logical forms .
The conversion process is illustrated in Figure 1 and discussed in more detail in Section 2 .
Whereas DEPLAMBDA works only for English , U-DEPLAMBDA applies to any language for which UD annotations are available .
1 Moreover , DEP -LAMBDA can only process tree-structured inputs whereas UDEPLAMBDA can also process dependency graphs , which allow to handle complex constructions such as control .
The different treatments of various linguistic constructions in UD compared to SD also require different handling in UDEP - LAMBDA ( Section 3.3 ) .
Our experiments focus on Freebase semantic parsing as a testbed for evaluating the framework 's multilingual appeal .
We convert natural language to logical forms which in turn are converted to machine interpretable formal meaning representations for retrieving answers to questions from Freebase .
To facilitate multilingual evaluation , we provide translations of the English WebQuestions ( Berant et al. , 2013 ) and GraphQuestions datasets to German and Spanish .
We demonstrate that UDEPLAMBDA can be used to derive logical forms for these languages using a minimal amount of language -specific knowledge .
Aside from developing the first multilingual semantic parsing tool for Freebase , we also experimentally show that U-DEPLAMBDA outperforms strong baselines across languages and datasets .
For English , it achieves the strongest result to date on GraphQuestions , with competitive results on WebQuestions .
Our implementation and translated datasets are publicly available at https://github.com/sivareddyg/udeplambda.
DEPLAMBDA
Before describing UDEPLAMBDA , we provide an overview of DEPLAMBDA on which our approach is based .
DEPLAMBDA converts a dependency tree to its logical form in three steps : binarization , substitution , and composition , each of which is briefly outlined below .
Algorithm 1 describes the steps of DEPLAMBDA in lines 4 - 6 , whereas lines 2 and 3 are specific to UDEPLAMBDA .
Binarization
A dependency tree is first mapped to a Lisp-style s-expression indicating the order of semantic composition .
Figure 1 ( b ) shows the s-expression for the sentence Disney won an Oscar for the movie Frozen , derived from the dependency tree in Figure 1 ( a ) .
Here , the sub-expression ( dobj won ( det Oscar an ) ) indicates that the logical form of the phrase won an Oscar is derived by composing the logical form of the label dobj with the logical form of the word won and the logical form of the phrase an Oscar , derived analogously .
The s-expression can also be interpreted as a binarized tree with the dependency label as the root node , and the left and right expressions as subtrees .
A composition hierarchy is employed to impose a strict traversal ordering on the modifiers to each head in the dependency tree .
As an example , won has three modifiers in Figure 1 ( a ) , which according to the composition hierarchy are composed in the order dobj > nmod > nsubj .
In constructions like coordination , this ordering is crucial to arrive at the correct semantics .
Lines 7 - 17 in Algorithm 1 describe the binarization step .
Substitution
Each symbol in the s-expressions is substituted for a lambda expression encoding its semantics .
Words and dependency labels are assigned different types of expressions .
In general , words have expressions of the following kind : ENTITY ? ?x. word ( x a ) ; e.g. Oscar ? ?x. Oscar( x a ) EVENT ? ?x. word ( x e ) ; e.g. won ? ?x. won( x e ) FUNCTIONAL ? ?x. TRUE ; e.g. an ? ?x. TRUE
Here , the subscripts ?
a and ?
e denote the types of individuals ( Ind ) and events ( Event ) , respectively , whereas x denotes a paired variable ( x a , x e ) Disney won an Oscar for the movie Frozen Figure 1 : The mapping of a dependency tree to its logical form with the intermediate s-expression .
of type Ind ?
Event .
Roughly speaking , proper nouns and adjectives invoke ENTITY expressions , verbs and adverbs invoke EVENT expressions , and common nouns invoke both ENTITY and EVENT expressions ( see Section 3.3 ) , while remaining words invoke FUNCTIONAL expressions .
DEPLAMBDA enforces the constraint that every s-expression is of the type ? = Ind ? Event ?
Bool , which simplifies the type system considerably .
Expressions for dependency labels glue the semantics of heads and modifiers to articulate predicate - argument structure .
These expressions in general take one of the following forms : COPY ? ? f gx. ?y. f ( x ) ? g( y ) ? rel(x , y ) e.g. nsubj , dobj , nmod , advmod INVERT ? ? f gx. ?y. f ( x ) ? g( y ) ? rel i ( y , x ) e.g. amod , acl MERGE ? ? f gx. f ( x ) ? g ( x ) e.g. compound , appos , amod , acl HEAD ? ? f gx. f ( x ) e.g. case , punct , aux , mark .
As an example of COPY , consider the lambda expression for dobj in ( dobj won ( det Oscar an ) ) : ? f gx. ?y. f ( x ) ? g( y ) ? arg 2 ( x e , y a ) .
This expression takes two functions f and g as input , where f represents the logical form of won and g represents the logical form of an Oscar .
The predicateargument structure arg 2 ( x e , y a ) indicates that the arg 2 of the event x e , i.e. won , is the individual y a , i.e. the entity Oscar .
Since arg 2 ( x e , y a ) mimics the dependency structure dobj( won , Oscar ) , we refer to the expression kind evoked by dobj as COPY .
Expressions that invert the dependency direction are referred to as INVERT ( e.g. amod in running horse ) ; expressions that merge two subexpressions without introducing any relation predicates are referred to as MERGE ( e.g. compound in movie Frozen ) ; and expressions that simply return the parent expression semantics are referred to as HEAD ( e.g. case in for Frozen ) .
While this generalization applies to most dependency labels , several labels take a different logical form not listed here , some of which are discussed in Section 3.3 .
Sometimes the mapping of dependency label to lambda expression may depend on surrounding part- of-speech tags or dependency labels .
For example , amod acts as INVERT when the modifier is a verb ( e.g. in running horse ) , and as MERGE when the modifier is an adjective ( e.g. in beautiful horse ) .
2 Lines 26 - 32 in Algorithm 1 describe the substitution procedure .
Composition
The final logical form is computed by beta-reduction , treating expressions of the form ( f x y ) as the function f applied to the arguments x and y .
For example , ( dobj won ( det Oscar an ) ) results in ?x. ?z. won( x e ) ? Oscar( z a ) ? arg 2 ( x e , z a ) when the expression for dobj is applied to those for won and ( det Oscar an ) .
Figure 1 ( c ) shows the logical form for the s-expression in Figure 1 ( b ) .
The binarized s-expression is recursively converted to a logical form as described in lines 18 - 25 in Algorithm 1 .
UDEPLAMBDA
We now introduce UDEPLAMBDA , a semantic interface for Universal Dependencies .
3 Whereas DEPLAMBDA only applies to English Stanford Dependencies , UDEPLAMBDA takes advantage of the cross-lingual nature of UD to facilitate an ( almost ) language independent semantic interface .
This is accomplished by restricting the binarization , substitution , and composition steps described above to rely solely on information encoded in the UD representation .
As shown in Algorithm 1 , lines 4 - 6 are common to both DEPLAMBDA and UDEP - LAMBDA , whereas lines 2 and 3 applies only to UDEPLAMBDA .
Importantly , UDEPLAMBDA is designed to not rely on lexical forms in a language 2 We use Tregex ( Levy and Andrew , 2006 ) for substitution mappings and Cornell SPF ( Artzi , 2013 ) as the lambdacalculus implementation .
For example , in running horse , the tregex / label: amod / =target < / postag : verb / matches amod to its INVERT expression ? f gx. ?y. f ( x ) ? g( y ) ? amod i ( y e , x a ) .
3
In what follows , all references to UD are to UD v1.3 .
to assign lambda expressions , but only on information contained in dependency labels and postags .
However , some linguistic phenomena are language specific ( e.g. pronoun-dropping ) or lexicalized ( e.g. every and the in English have different semantics , despite being both determiners ) and are not encoded in the UD schema .
Furthermore , some cross-linguistic phenomena , such as long-distance dependencies , are not part of the core UD representation .
To circumvent this limitation , a simple enhancement step enriches the original UD representation before binarization takes place ( Section 3.1 ) .
This step adds to the dependency tree missing syntactic information and long-distance dependencies , thereby creating a graph .
Whereas DEPLAMBDA is not able to handle graph-structured input , UDEP -LAMBDA is designed to work with dependency graphs as well ( Section 3.2 ) .
Finally , several constructions differ in structure between UD and SD , which requires different handling in the semantic interface ( Section 3.3 ) .
Enhancement Both Schuster and Manning ( 2016 ) and note the necessity of an enhanced UD representation to enable semantic applications .
However , such enhancements are currently only available for a subset of languages in UD .
Instead , we rely on a small number of enhancements for our main application -semantic parsing for questionanswering - with the hope that this step can be replaced by an enhanced UD representation in the future .
Specifically , we define three kinds of enhancements : ( 1 ) long-distance dependencies ; ( 2 ) types of coordination ; and ( 3 ) refined question word tags .
These correspond to line 2 in Algorithm 1 .
First , we identify long-distance dependencies in relative clauses and control constructions .
We follow Schuster and Manning ( 2016 ) and find these using the labels acl ( relative ) and xcomp ( control ) .
Figure 2 ( a ) shows the long-distance dependency in the sentence Anna wants to marry Kristoff .
Here , marry is provided with its missing nsubj ( dashed arc ) .
Second , UD conflates all coordinating constructions to a single dependency label , conj .
To obtain the correct coordination scope , we refine conj to conj:verb , conj : vp , conj :sentence , conj:np , and conj:adj , similar to .
Finally , unlike the PTB tags ( Marcus et al. , 1993 ) used by SD , the UD part- of-speech tags do not distinguish question words .
Since these are crucial to question - answering , we use a small lexicon to refine the tags for determiners ( DET ) , adverbs ( ADV ) and pronouns ( PRON ) to DET :WH , ADV :WH and PRON : WH , respectively .
Specifically , we use a list of 12 ( English ) , 14 ( Spanish ) and 35 ( German ) words , respectively .
This is the only part of UDEPLAMBDA that relies on language -specific information .
We hope that , as the coverage of morphological features in UD improves , this refinement can be replaced by relying on morphological features , such as the interrogative feature ( INT ) .
Graph Structures and BIND
To handle graph structures that may result from the enhancement step , such as those in Figure 2 from that of DEPLAMBDA .
This is indicated in line 3 of Algorithm 1 .
First , each long-distance dependency is split into independent arcs as shown in Figure 2 ( b ) .
Here , ? is a placeholder for the subject of marry , which in turn corresponds to Anna as indicated by the binding of ? via the pseudo-label BIND .
We treat BIND like an ordinary dependency label with semantics MERGE and process the resulting tree as usual , via the s-expression : ( nsubj ( xcomp wants ( nsubj ( mark ( dobj marry Kristoff ) to ) ? ) ( BIND Anna ? ) ) , with the lambda-expression substitutions :
These substitutions are based solely on unlexicalized context .
For example , the part- of-speech tag PROPN of Anna invokes an ENTITY expression .
The placeholder ? has semantics ?x.EQ ( x , ? ) , where EQ ( u , ? ) is true iff u and ? are equal ( have the same denotation ) , which unifies the subject variable of wants with the subject variable of marry .
After substitution and composition , we get :
This expression encodes the fact that Anna is the arg 1 of the marry event , as desired .
DEPLAMBDA , in contrast , cannot handle graph-structured input , since it lacks a principled way of generating sexpressions from graphs .
Even given the above s-expression , BIND in DEPLAMBDA is defined in a way such that the composition fails to unify v and x , which is crucial for the correct semantics .
Moreover , the definition of BIND in DEPLAMBDA does not have a formal interpretation within the lambda calculus , unlike ours .
Linguistic Constructions
Below , we highlight the most pertinent differences between UDEPLAMBDA and DEPLAMBDA , stemming from the different treatment of various linguistic constructions in UD versus SD .
Prepositional Phrases UD uses a content-head analysis , in contrast to SD , which treats function words as heads of prepositional phrases , Accordingly , the s-expression for the phrase president in 2009 is ( nmod president ( case 2009 in ) ) in U-DEPLAMBDA and ( prep president ( pobj in 2009 ) ) in DEPLAMBDA .
To achieve the desired semantics , Other nmod constructions , such as possessives ( nmod:poss ) , temporal modifiers ( nmod:tmod ) and adverbial modifiers ( nmod:npmod ) , are handled similarly .
Note how the common noun president , evokes both entity and event predicates above .
Passives DEPLAMBDA gives special treatment to passive verbs , identified by the fine- grained partof-speech tags in the PTB tag together with dependency context .
For example , An Oscar was won is analyzed as ?x. won.pass ( x e ) ? Oscar(y a ) ? arg 1 ( x e , y a ) , where won . pass represents a passive event .
However , UD does not distinguish between active and passive forms .
4
While the labels nsubjpass or auxpass indicate passive constructions , such clues are sometimes missing , such as in reduced relatives .
We therefore opt to not have separate entries for passives , but aim to produce identical logical forms for active and passive forms when possible ( for example , by treating nsubjpass as direct object ) .
With the following entries , won ?
EVENT ; an , was ?
FUNCTIONAL ; auxpass ?
HEAD ; nsubjpass = ? f gx. ?y. f ( x ) ? g( y ) ? arg 2 ( x e , y a ) , the lambda expression for An Oscar was won becomes ?x. won( x e ) ?
Oscar(y a ) ? arg 2 ( x e , y a ) , identical to that of its active form .
However , not having a special entry for passive verbs may have undesirable side-effects .
For example , in the reducedrelative construction Pixar claimed the Oscar won for Frozen , the phrase the Oscar won ... will receive the semantics ?x. Oscar(y a ) ? won( x e ) ? arg 1 ( x e , y a ) , which differs from that of an Oscar was won .
We leave it to the target application to disambiguate the interpretation in such cases .
Long-Distance Dependencies
As discussed in Section 3.2 , we handle long-distance dependencies evoked by clausal modifiers ( acl ) and control verbs ( xcomp ) with the BIND mechanism , whereas DEPLAMBDA cannot handle control constructions .
For xcomp , as seen earlier , we use the mapping ? f gx . ?y. f ( x ) ? g( y ) ?xcomp( x e , y e ) .
For acl we use ? f gx. ?y. f ( x ) ? g ( y ) , to conjoin the main clause and the modifier clause .
However , not all acl clauses evoke long-distance dependencies , e.g. in the news that Disney won an Oscar , the clause that Disney won an Oscar is a subordinating conjunction of news .
In such cases , we instead assign acl the INVERT semantics .
Questions Question words are marked with the enhanced part-of-speech tags DET : WH , ADV :WH and PRON : WH , which are all assigned the semantics ?x. $ { word } ( x a ) ? TARGET ( x a ) .
The predicate TARGET indicates that x a represents the variable of interest , that is the answer to the question .
Limitations
In order to achieve language independence , UDEP -LAMBDA has to sacrifice semantic specificity , since in many cases the semantics is carried by lexical information .
Consider the sentences John broke the window and The window broke .
Although it is the window that broke in both cases , our inferred logical forms do not canonicalize the relation between broke and window .
To achieve this , we Figure 3 : The ungrounded graphs for What language do the people in Ghana speak ? , Welche Sprache wird in Ghana gesprochen ?
and Cu?l es la lengua de Ghana ? , and the corresponding grounded graph .
would have to make the substitution of nsubj depend on lexical context , such that when window occurs as nsubj with broke , the predicate arg 2 is invoked rather than arg 1 . UDEPLAMBDA does not address this problem , and leave it to the target application to infer context-sensitive semantics of arg 1 and arg 2 .
To measure the impact of this limitation , we present UDEPLAMBDASRL in Section 4.4 which addresses this problem by relying on semantic roles from semantic role labeling ( Palmer et al. , 2010 ) .
Other constructions that require lexical information are quantifiers like every , some and most , negation markers like no and not , and intentional verbs like believe and said .
UD does not have special labels to indicate these .
We discuss how to handle quantifiers in this framework in the supplementary material .
Although in the current setup UDEPLAMBDA rules are hand-coded , the number of rules are only proportional to the number of UD labels , making rule-writing manageable .
5 Moreover , we view UDEPLAMBDA as a first step towards learning rules for converting UD to richer semantic representations such as PropBank , AMR , or the Parallel Meaning Bank ( Palmer et al. , 2005 ; Banarescu et al. , 2013 ; Abzianidze et al. , 2017 ) ..
Semantic Parsing as Graph Matching UDEPLAMBDA generates ungrounded logical forms that are independent of any knowledge base , such as Freebase .
We use GRAPHPARSER to map these logical forms to their grounded Freebase graphs , via corresponding ungrounded graphs .
Figures 3 ( a ) to 3 ( c ) show the ungrounded graphs corresponding to logical forms from UDEPLAMBDA , each grounded to the same Freebase graph in Figure 3 ( d ) .
Here , rectangles denote entities , circles denote events , rounded rectangles denote entity types , and edges between events and entities denote predicates or Freebase relations .
Finally , the TARGET node represents the set of values of x that are consistent with the Freebase graph , that is the answer to the question .
GRAPHPARSER treats semantic parsing as a graph-matching problem with the goal of finding the Freebase graphs that are structurally isomorphic to an ungrounded graph and rank them according to a model .
To account for structural mismatches , GRAPHPARSER uses two graph transformations : CONTRACT and EXPAND .
In Figure 3 ( a ) there are two edges between x and Ghana .
CONTRACT collapses one of these edges to create a graph isomorphic to Freebase .
EXPAND , in contrast , adds edges to connect the graph in the case of disconnected components .
The search space is explored by beam search and model parameters are estimated with the averaged structured perceptron ( Collins , 2002 ) from training data consisting of question - answer pairs , using answer F 1 - score as the objective .
Datasets
We evaluate our approach on two public benchmarks of question answering against Freebase : WebQuestions ( Berant et al. , 2013 ) , a widely used benchmark consisting of English questions and their answers , and GraphQuestions , a recently released dataset of English questions with both their answers and grounded logical forms .
While WebQuestions is dominated by simple entityattribute questions , GraphQuestions contains a large number of compositional questions involving aggregation ( e.g. How many children of Eddard Stark were born in Winterfell ? ) and comparison ( e.g .
In which month does the average rainfall of New York City exceed 86 mm ? ) .
The number of training , development and test questions is 2644 , 1134 , and 2032 , respectively , for WebQuestions and 1794 , 764 , and 2608 for GraphQuestions .
To support multilingual evaluation , we created translations of WebQuestions and GraphQuestions to German and Spanish .
For WebQuestions two professional annotators were hired per language , while for GraphQuestions we used a trusted pool of 20 annotators per language ( with a single annotator per question ) .
Examples of the original questions and their translations are provided in Table 1 .
Implementation Details
Here we provide details on the syntactic analyzers employed , our entity resolution algorithm , and the features used by the grounding model .
Dependency Parsing
The English , Spanish , and German Universal Dependencies ( UD ) treebanks ( v1.3 ; Nivre et al 2016 ) were used to train part of speech taggers and dependency parsers .
We used a bidirectional LSTM tagger ( Plank et al. , 2016 ) and a bidirectional LSTM shift-reduce parser ( Kiperwasser and Goldberg , 2016 ) .
Both the tagger and parser require word embeddings .
For English , we used GloVe embeddings ( Pennington et al. , 2014 ) trained on Wikipedia and the Gigaword corpus .
For German and Spanish , we used SENNA embeddings ( Collobert et al. , 2011 ; Al - Rfou et al. , 2013 ) trained on Wikipedia corpora ( 589 M words German ; 397 M words Spanish ) .
6 Measured on the UD test sets , the tagger accuracies are 94.5 ( English ) , 92.2 ( German ) , and 95.7 ( Spanish ) , with corresponding labeled attachment parser scores of 81.8 , 74.7 , and 82.2 .
Entity Resolution
We follow and resolve entities in three steps : ( 1 ) potential entity spans are identified using seven handcrafted part- of-speech patterns ; ( 2 ) each span is associated with potential Freebase entities according to the Freebase / KG API ; and ( 3 ) the 10 - best entity linking lattices , scored by a structured perceptron , are 6 https://sites.google.com/site/rmyeid/projects/polyglot.
WebQuestions en
What language do the people in Ghana speak ?
de Welche Sprache wird in Ghana gesprochen ?
es ?Cu?l es la lengua de Ghana ?
input to GRAPHPARSER , leaving the final disambiguation to the semantic parsing problem .
Table 2 shows the 1 - best and 10 - best entity disambiguation F 1 - scores for each language and dataset .
Features
We use features similar to : basic features of words and Freebase relations , and graph features crossing ungrounded events with grounded relations , ungrounded types with grounded relations , and ungrounded answer type crossed with a binary feature indicating if the answer is a number .
In addition , we add features encoding the semantic similarity of ungrounded events and Freebase relations .
Specifically , we used the cosine similarity of the translation - invariant embeddings of Huang et al . ( 2015 ) . 7
Comparison Systems
We compared UDEPLAMBDA to four versions of GRAPHPARSER that operate on different representations , in addition to prior work .
SINGLEEVENT
This model resembles the learning - to - rank model of Bast and Haussmann ( 2015 ) .
An ungrounded graph is generated by connecting all entities in the question with the TARGET node , representing a single event .
Note that this Table 3 : F 1 - scores on the test data .
baseline cannot handle compositional questions , or those with aggregation or comparison .
DEPTREE
An ungrounded graph is obtained directly from the original dependency tree .
An event is created for each parent and its dependents in the tree .
Each dependent is linked to this event with an edge labeled with its dependency relation , while the parent is linked to the event with an edge labeled arg 0 .
If a word is a question word , an additional TARGET predicate is attached to its entity node .
CCGGRAPH
This is the CCG - based semantic representation of Reddy et al . ( 2014 ) .
Note that this baseline exists only for English .
UDEPLAMBDASRL
This is similar to UDEP - LAMBDA except that instead of assuming nsubj , dobj and nsubjpass correspond to arg 1 , arg 2 and arg 2 , we employ semantic role labeling to identify the correct interpretation .
We used the systems of Roth and Woodsend ( 2014 ) for English and German and Bjrkelund et al . ( 2009 ) for Spanish trained on the CoNLL - 2009 dataset ( Haji et al. , 2009 ) . 8
Results
Table 3 shows the performance of GRAPHPARSER with these different representations .
Here and in what follows , we use average F 1 - score of predicted answers ( Berant et al. , 2013 ) as the evaluation metric .
We first observe that UDEPLAMBDA consistently outperforms the SINGLEEVENT and DEP - TREE representations in all languages .
For English , performance is on par with CCG - GRAPH , which suggests that UDEPLAMBDA does not sacrifice too much specificity for universality .
With both datasets , results are lower for German compared to Spanish .
This agrees with the lower performance of the syntactic parser on the German portion of the UD treebank .
While U-DEPLAMBDASRL performs better than UDEP - Method GraphQ .
WebQ.
SEMPRE ( Berant et al. , 2013 ) 10.8 35.7 JACANA ( Yao and Van Durme , 2014 ) 5.1 33.0 PARASEMPRE ( Berant and Liang , 2014 ) 12.8 39.9 QA ( Yao , 2015 ) - 44.3 AQQU ( Bast and Haussmann , 2015 ) - 49.4 AGENDAIL ( Berant and Liang , 2015 ) - 49.7 DEPLAMBDA LAMBDA on WebQuestions for English , we do not see large performance gaps in other settings , suggesting that GRAPHPARSER is either able to learn context-sensitive semantics of ungrounded predicates or that the datasets do not contain ambiguous nsubj , dobj and nsubjpass mappings .
Finally , while these results confirm that GraphQuestions is much harder compared to WebQuestions , we note that both datasets predominantly contain single - hop questions , as indicated by the competitive performance of SINGLEEVENT on both datasets .
Table 4 compares UDEPLAMBDA with previously published models which exist only for English and have been mainly evaluated on Web-Questions .
These are either symbolic like ours ( first block ) or employ neural networks ( second block ) .
Results for models using additional task-specific training resources , such as ClueWeb09 , Wikipedia , or SimpleQuestions ( Bordes et al. , 2015 ) are shown in parentheses .
On GraphQuestions , we achieve a new state - of - the - art result with a gain of 4.8 F 1 points over the previously reported best result .
On WebQuestions we are 2.1 points below the best model using comparable resources , and 3.8 points below the state of the art .
Most related to our work is the English-specific system of .
We attribute the 0.8 point difference in F 1 score to their use of the more fine - grained PTB tag set and Stanford Dependencies .
Related Work
Our work continues the long tradition of building logical forms from syntactic representations initiated by Montague ( 1973 ) .
The literature is rife with attempts to develop semantic interfaces for HPSG ( Copestake et al. , 2005 ) , LFG ( Kaplan and Bresnan , 1982 ; Dalrymple et al. , 1995 ; Crouch and King , 2006 ) , TAG ( Kallmeyer and Joshi , 2003 ; Gardent and Kallmeyer , 2003 ; Nesson and Shieber , 2006 ) , and CCG ( Baldridge and Kruijff , 2002 ; Bos et al. , 2004 ; Artzi et al. , 2015 ) .
Unlike existing semantic interfaces , UDEPLAMBDA uses dependency syntax , a widely available syntactic resource .
A common trend in previous work on semantic interfaces is the reliance on rich typed feature structures or semantic types coupled with strong type constraints , which can be very informative but unavoidably language specific .
Instead , UDEP -LAMBDA relies on generic unlexicalized information present in dependency treebanks and uses a simple type system ( one type for dependency labels , and one for words ) along with a combinatory mechanism , which avoids type collisions .
Earlier attempts at extracting semantic representations from dependencies have mainly focused on languagespecific dependency representations ( Spreyer and Frank , 2005 ; Simov and Osenova , 2011 ; Hahn and Meurers , 2011 ; Falke et al. , 2016 ; Beltagy , 2016 ) , and multi-layered dependency annotations ( Jakob et al. , 2010 ; B?daride and Gardent , 2011 ) .
In contrast , UDEPLAMBDA derives semantic representations for multiple languages in a common schema directly from Universal Dependencies .
This work parallels a growing interest in creating other forms of multilingual semantic representations ( Akbik et al. , 2015 ; Vanderwende et al. , 2015 ; White et al. , 2016 ; Evang and Bos , 2016 ) .
We evaluate UDEPLAMBDA on semantic parsing for question answering against a knowledge base .
Here , the literature offers two main modeling paradigms : ( 1 ) learning of task -specific grammars that directly parse language to a grounded representation ( Zelle and Mooney , 1996 ; Zettlemoyer and Collins , 2005 ; Berant et al. , 2013 ; Flanigan et al. , 2014 ; Pasupat and Liang , 2015 ; Groschwitz et al. , 2015 ) ; and ( 2 ) converting language to a linguistically motivated task - independent representation that is then mapped to a grounded representation ( Kwiatkowski et al. , 2013 ; Reddy et al. , 2014 ; Krishnamurthy and Mitchell , 2015 ; Gardner and Krishnamurthy , 2017 ) .
Our work belongs to the latter paradigm , as we map natural language to Freebase indirectly via logical forms .
Capitalizing on natural - language syntax affords interpretability , scalability , and reduced duplication of effort across applications ( Bender et al. , 2015 ) .
Our work also relates to literature on parsing multiple languages to a common executable representation ( Cimiano et al. , 2013 ; Haas and Riezler , 2016 ) .
However , existing approaches still map to the target meaning representations ( more or less ) directly ( Kwiatkowksi et al. , 2010 ; Jones et al. , 2012 ; Jie and Lu , 2014 ) .
Conclusions
We introduced UDEPLAMBDA , a semantic interface for Universal Dependencies , and showed that the resulting semantic representation can be used for question - answering against a knowledge base in multiple languages .
We provided translations of benchmark datasets in German and Spanish , in the hope to stimulate further multilingual research on semantic parsing and question answering in general .
We have only scratched the surface when it comes to applying UDEPLAMBDA to natural language understanding tasks .
In the future , we would like to explore how this framework can benefit applications such as summarization ( Liu et al. , 2015 ) and machine reading ( Sachan and Xing , 2016 ) .
The dependency tree for Disney won an Oscar for the movie Frozen in the Universal Dependencies formalism .( nsubj ( nmod ( dobj won ( det Oscar an ) ) ( case ( det ( comp.
Frozen movie ) the ) for ) ) Disney ) ( b) The binarized s-expression for the dependency tree .
?x. ?yzw. won( x e ) ? Disney(y a ) ? Oscar( z a ) ? Frozen( w a ) ? movie( w a ) ? arg 1 ( x e , y a ) ? arg 2 ( x e , z a ) ? nmod.for( x e , w a ) ( c ) The composed lambda-calculus expression .
3 bindedTree= SplitLongDistance ( depGraph ) # See Figure 2 ( b ) for a binded Tree .4 binarized Tree = Binarization ( bindedTree ) # See Figure 1 ( b ) for a binarized Tree .
= Composition ( binarziedTree.le f t ) 22 rightLF = Composition ( binarziedTree.right ) 23 mainLF = BetaReduce ( mainLF , le f tLF ) 24 mainLF = BetaReduce ( mainLF , rightLF )
( a ) , we propose a variable - binding mechanism that differs Anna wants to marry Kristoff
Figure 2 : 2 Figure 2 : The original and enhanced dependency trees for Anna wants to marry Kristoff .
?z. ?xywv. wants ( z e ) ? Anna( x a ) ? arg 1 ( z e , x a ) ? EQ ( x , ? ) ? marry(y e ) ? xcomp ( z e , y e ) ? arg 1 ( y e , v a ) ? EQ ( v , ? ) ? Kristoff ( w a ) ? arg 2 ( y e , w a ) ,
This expression may be simplified further by replacing all occurrences of v with x and removing the unification predicates EQ , which results in :?z. ?xyw. wants ( z e ) ? Anna( x a ) ? arg 1 ( z e , x a ) ? marry(y e ) ? xcomp ( z e , y e ) ? arg 1 ( y e , x a ) ? Kristoff ( w a ) ? arg 2 ( y e , w a ) .
?x. ?y. president ( x a ) ? president event ( x e ) ? arg 1 ( x e , x a ) ? 2009 ( y a ) ? prep.in( x e , y a ) , DEPLAMBDA relies on an intermediate logical form that requires some post-processing , whereas UDEPLAMBDA obtains the desired logical form directly through the following entries : in ? FUNCTIONAL ; 2009 ? ENTITY ; case ? HEAD ; president = ?x. president ( x a ) ? president event ( x e ) ? arg 1 ( x e , x a ) ; nmod = ? f gx. ?y. f ( x ) ? g( y ) ? nmod.in( x e , y a ) .
Table 1 : 1 Example questions and their translations .
en Who was Vincent van Gogh inspired by ?
de Von wem wurde Vincent van Gogh inspiriert ?
es ?Qu? inspir ?
a Van Gogh ?
GraphQuestions en NASA has how many launch sites ?
de Wie viele Abschussbasen besitzt NASA ?
es ?Cu?ntos sitios de despegue tiene NASA ?
en
Which loudspeakers are heavier than 82.0 kg?
de Welche Lautsprecher sind schwerer als 82.0 kg?
es ?Qu? altavoces pesan m?s de 82.0 kg?
k WebQuestions GraphQuestions en de es en de es 1 89.6 82.8 86.7 47.2 39.9 39.5 10 95.7 91.2 94.0 56.9 48.4 51.6
Table 2 : 2 Structured perceptron k-best entity linking accuracies on the development sets .
Table 4 : 4 F 1 - scores on the English GraphQuestions and WebQuestions test sets ( results with additional task-specific resources in parentheses ) . ) - 50.3 STAGG ( Yih et al. , 2015 ) - 48.4 ( 52.5 ) BILSTM ( T?re and Jojic , 2016 ) - 24.9 ( 52.2 ) MCNN ( Xu et al. , 2016 ) - 47.0 ( 53.3 ) AGENDAIL-RANK ( Yavuz et al. , 2016 ) - 51.6 ( 52.6 ) UDEPLAMBDA 17.7 49.5
As of v1.3 , UD annotations are available for 47 languages at http://universaldependencies.org.
UD encodes voice as a morphological feature , but most syntactic analyzers do not produce this information yet .
Cross-lingual Semantic ParsingTo study the multilingual nature of UDEPLAMBDA , we conduct an empirical evaluation on question answering against Freebase in three different languages : English , Spanish , and German .
Before discussing the details of this experiment , we briefly outline the semantic parsing framework employed .5 UD v1.3 has 40 dependency labels , and the number of substitution rules in UDEPLAMBDA are 61 , with some labels having multiple rules , and some representing lexical semantics .
http://128.2.220.95/multilingual/data/.
The parser accuracies ( % ) are 87.33 , 81.38 and 79.91 for English , German and Spanish respectively .
