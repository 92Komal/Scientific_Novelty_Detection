title
Parsing Gapping Constructions Based on Grammatical and Semantic Roles
abstract
A gapping construction consists of a coordinated structure where redundant elements are elided from all but one conjuncts .
This paper proposes a method of parsing sentences with gapping to recover elided elements .
The proposed method is based on constituent trees annotated with grammatical and semantic roles that are useful for identifying elided elements .
Our method outperforms the previous method in terms of F-measure and recall .
Introduction
A gapping construction consists of a coordinated structure where redundant elements are elided from all but one conjuncts .
For example , we can elide the second redundant verb " ate " from the sentence " John ate bread , and Mary ate rice . "
We need to recover elided elements to interpret sentences with gapping ; however , little work has focused on developing such methods .
This paper proposes a method of parsing sentences with gapping .
Our proposed method uses constituent trees annotated with grammatical and semantic tags and a special tag indicating gapped conjuncts .
The method parses a sentence to obtain a tag-annotated constituent tree and analyzes gapping constructions using the resulting tree when it includes gapped conjuncts .
The analysis is based on a sequence alignment algorithm using grammatical and semantic tags .
An experiment shows that our method outperforms the previous method in terms of F-measure and recall .
Gapping Construction
This section first explains gapping constructions in the Penn Treebank ( PTB , Marcus et al. , 1993 ) , on which our proposed method is based , and summarizes the previous work on analyzing sentences with gapping .
Gapping Constructions in the PTB A gapping construction consists of a coordinated structure where redundant elements are elided from all but one conjuncts .
The constituents remaining in a gapped conjunct are called remnants .
The remnants have a corresponding constituent , called a correlate , in the ungapped conjunct .
1
We can obtain the ungapped version of the conjunct by replacing each correlate with its corresponding remnant .
In the PTB , the correspondences between remnants and correlates are annotated .
Figure 1 shows an example of a PTB constituent tree , which includes a gapping construction .
The nodes marked with " - " hyphen indices are the correlates , while those marked with " = " equal indices are the remnants .
A gapped conjunct is flattened , that is , all remnants are children of the conjunct node .
The number assigned to a correlate and a remnant indicates a correspondence relation .
For example , NP - SBJ - 1 and NP - SBJ=1 in this tree are a correlate and a remnant , respectively , and correspond to each other .
We can obtain the constituent tree for " the six-month bills will still mature on May 3 , 1990 " by replacing NP - SBJ - 1 with the tree whose root is NP - SBJ=1 and NP - TMP - 2 with that whose root is PP - TMP=2 .
In other words , " will still mature " is elided from the second conjunct .
Previous Work
This section gives an overview of previous approaches to analyzing sentences with gapping .
Ficler and Goldberg ( 2016 ) proposed a new representation for argument -cluster coordination , which is one kind of gapping constructions .
They converted PTB trees by coordinating correlates and remnants .
This conversion can be applied only when the correlates and the remnants are all to - gether on the right .
Therefore , it cannot handle the tree shown in Figure 1 . Kummerfeld and Klein ( 2017 ) developed a parser that adopts a graph representation for syntactic structure .
They discussed how to represent a correspondence between a remnant and a correlate with an arc in their graph representation .
However , the parser struggled to generate such arcs , and the recall was very low .
2 Schuster et al. ( 2018 ) proposed two methods based on dependency structure .
One represents gapping constructions using complex relation labels ( Seeker et al. , 2012 ) , and the other adopts a sequence alignment algorithm to assign remnant words to correlate words .
The latter is similar to ours .
We will discuss the differences between the latter method and ours in the later section .
Another approach is the one that does not depend on syntactic representation .
In the Automatic Gapping Resolution Shared Task for Russian ( AGRR - 2019 ) ( Ponomareva et al. , 2019 ) , the prepared dataset marked each element comprising gapping constructions .
Most participants treated this task as a sequence labeling problem .
Proposed Method
This section describes our proposed method , which parses gapping constructions .
Our method enables existing PTB - based parsers to identify correspondences between correlates and remnants .
Elided elements can be recovered by such correspondences as described in Section 2.1 .
One difficulty in parsing gapping constructions is insufficient data for modeling such phenomena because their occurrence is rare .
To mitigate this problem , our method learns not directly from correspondences between correlates and remnants , but from the following tags easily obtained from the PTB : ? a special tag indicating gapped conjuncts
? grammatical and semantic role tags Correspondences between correlates and remnants are identified by a sequence alignment algorithm using the tag-annotated constituent tree .
We first explain our tag annotation and describe the sequence alignment algorithm .
Annotation
Our method uses a special tag to identify gapped conjuncts in constituency parsing .
Specifically , we assign the GAP tag to a node n , if n satisfies the following condition : ? n has a child marked with " = " index .
In the coordinated structure shown in Figure 1 , the GAP tag is assigned to the second S conjunct node .
Next , we explain grammatical and semantic tags .
In general , each remnant and its corresponding correlate play an identical grammatical or semantic role .
For example , in Figure 1 , the constituents co-indexed with 1 are subjects ( SBJ ) , while those co-indexed with 2 are temporal adjuncts ( TMP ) .
This fact suggests that correspondences between correlates and remnants can be identified using grammatical and semantic roles .
Our method directly uses the PTB grammatical and semantic role tags shown in Table 1 . 3 An important point herein is that our method has an advantage from the viewpoint of training data .
The PTB includes a massive amount of grammatical and semantic tag information ; thus , we can learn a model that identifies the tags by simply retaining them in the treebank ( Gabbard et al. , 2006 ) .
How to identify correspondences between correlates and remnants
This section explains how to identify correspondences between correlates and remnants using the tag-annotated constituent trees described in the previous section .
The procedure consists of the following two steps :
1 . Extract remnant candidates R and correlate candidates C when gapped conjuncts exist .
Align nodes in R to nodes in C .
The first step is invoked if a node n g annotated with the GAP tag exists .
A set R of remnant candidates is defined as a set of n g 's children .
To extract the correlate candidates C , the method seeks the ungapped conjunct n u that satisfies the following condition : n u ?
L( n g ) ? ct ( n u ) = ct ( n g ) ? ?n ? L( n u ) ( ct ( n ) = ct ( n u ) ) where , L( n ) and ct ( n ) are the set of left siblings of n and the category of n , respectively .
A set C of correlate candidates is defined as a set of n u 's proper descendants .
The second step aligns nodes in R to nodes in C .
Here we impose a constraint that r ?
R plays an identical role to c ?
C. More precisely , we can align r to c if the following condition holds : match ( c , r ) def = ( rl ( c ) = rl ( r ) ? = null ) ? ( ct ( c ) = ct ( r ) = PP ? hd ( c ) = hd ( r ) ) ? ( rl ( c ) = rl ( r ) = null ? ct ( c ) = ct ( r ) ) where , rl ( x ) stands for the role tag of x .
If x has no role tag , rl ( x ) = null . hd( x ) is the head preposition of x .
Furthermore , we impose the following structural constraints to follow the PTB annotation scheme : Uniqueness of remnant If ( c , r ) ?
A and ( c , r ? ) ?
A , then r = r ? . Uniqueness of correlate If ( c , r ) ?
A and ( c ? , r ) ?
A , then c = c ? . Order-Preserving For all ( c , r ) , ( c ? , r ? ) ? A , if e( r ) ? s( r ? ) , then e( c ) ? s( c ? ) . Non-overlapping For all ( c , r ) , ( c ? , r ? ) ? A ( c ? = c ? ) , then e( c ) ? s( c ? ) or e( c ? ) ? s ( c ) .
Here , A ? C ?
R is a set representing an alignment of correlates to remnants . ( c , r ) ?
A means that a correlate c is aligned to a remnant r. s( n ) and e( n ) stand for the start and end positions of node n , respectively .
DP - based sequence alignment
To realize the second step described in Section 3.2 , we modify the sequence alignment algorithm proposed by Needleman and Wunsch ( 1970 ) . T[ i , n ] ? ?{} , 0 ? 4 : end for 5 : for j = 0 to n do 6 : T [ m , j ] ? ?{} , 0 ? 7 : end for 8 : for i = m ?
1 down to 0 do 9 : for j = n ?
1 down to 0 do 10 : ?A , s? ? T[ skip-des [ i ] , j + 1 ] 11 : Match ? ?A ? {( ci , rj ) } , s + score ( ci , rj ) ?
12 : T[ i , j ] ? arg max T ?{T [ i+1 , j ] , T [ i , j+ 1 ] , Match } Score ( T ) 13 : end for 14 : end for 15 : return T [ 0 , 0 ]
Discussion
Our method is similar to that of Schuster et al . ( 2018 ) in that both rely on sequence alignment .
The following differences , however , exist : ?
The previous method converts Universal Dependencies ( UD ) v2 representations ( Nivre et al. , 2017 ) to enhanced UD representations ( Schuster and Manning , 2016 ) , which provides an analysis of gapping constructions .
It cannot use grammatical and semantic roles unlike ours , because remnants cannot have such information in the UD v2 framework .
6 ? Our proposed sequence alignment algorithm is a novel one that can impose the orderpreserving and non-overlapping constraints on the resulting alignment .
This feature is required to deal with gapping constructions in PTB constituent trees .
Experiment
We conducted an experiment using the PTB to evaluate the performance of our proposed method .
7
We used the standard PTB training , development , and test data split ( i.e. , sections 02 - 21 , 22 , and 23 , respectively ) and the Kitaev and Klein parser ( Kitaev and Klein , 2018 ) 8 that can use BERT ( Devlin et al. , 2019 ) development data with those annotated by our annotation scheme .
The hyperparameters were identical to those of Kitaev et al . ( 2019 ) .
The test data were parsed by the trained model to obtain tagannotated trees .
The correspondences between the correlates and the remnants were identified by our proposed alignment algorithm .
The alignment accuracy was evaluated by the metric of Kummerfeld and Klein ( 2017 ) .
That is , we represent a correspondence between a correlate c and a remnant r as a tuple ( ct ( r ) , s ( r ) , e ( r ) , ct ( c ) , s ( c ) , e( c ) ) , and measure the precision and recall using tuples .
Table 2 shows the alignment performance of our method and the previous one .
The previous method struggled to generate arcs between correlates and remnants and had a very low recall .
In contrast , our method achieved high recall and F-measure .
It outperformed the previous method even without BERT .
The last row in Table 2 shows the performance when using gold tag-annotated trees , indicating that our sequence alignment algorithm works well and that tag identification directly affects the overall performance .
We evaluated the tag identification accuracy using a tuple ( rl ( n ) , s ( n ) , e( n ) ) .
Table 3 presents the tag identification accuracy .
The performance of identifying grammatical and semantic tags did not differ much between using BERT and not using BERT .
On the other hand , the performance of identifying the GAP tag without BERT is rather low compared to that with BERT .
Therefore , the main reason for the low performance of the alignment without BERT is the degraded performance of identifying the GAP tag .
Finally , we report the constituency parsing performance .
Table 4 shows the accuracy of the Kitaev and Klein parser with and without our tag annotation .
The result implies that our tag annotation to constituent trees has a tiny negative impact on the constituency parsing performance .
Conclusion
This paper has proposed a method of parsing gapping constructions based on tag-annotated constituent trees .
Our proposed method is simple but effective .
We believe that it will serve as a strong baseline for the task of parsing gapping constructions .
In the future work , we will extend our method by replacing the simple role matching score with grammatical or semantic similaritybased measures to improve the alignment accuracy .
Figure 1 : 1 Figure
